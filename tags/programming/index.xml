<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on OhCoder</title><link>https://ohcoder.com/tags/programming/</link><description>Recent content in programming on OhCoder</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 21 Apr 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://ohcoder.com/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>读《代码大全（第二版）》笔记（七）</title><link>https://ohcoder.com/post/2013/04/21/reading-code-complete7/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/04/21/reading-code-complete7/</guid><description>&lt;img src="https://ohcoder.com/post/2013/04/21/reading-code-complete7/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（七）" />&lt;p>本周读完第七部分。第七部分也是本书的最后一部分，讲的主题是&lt;!-- raw HTML omitted -->软件工艺&lt;!-- raw HTML omitted -->。此部分一共分为五章，涉及的内容关联性不大，比较杂乱，主要包括代码的书写格式，以及良好的注释应该如何写。另外还包括一章专门讲程序员性格的，我觉得也是蛮有意思的。对于我这种天生脑子不太好使的同学，看完这一章之后似乎又看到了一丝前途的光明。最后两章讲的比较泛泛了，说的比较零散，涉及到很多常识类的大道理。下面简要总结一下。&lt;/p>
&lt;h2 id="第三十一章布局与风格">第三十一章——布局与风格&lt;/h2>
&lt;p>本章主要讲了代码编写的格式问题。套用书中的话叫&lt;/p>
&lt;blockquote>
&lt;p>(Page.729)本章转向计算机的编程的美学话题——程序源代码的布局。&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;em>布局的极端情况&lt;/em> 这一节中，书中列举了一些格式混乱的代码，作为反面例子。&lt;/p>
&lt;blockquote>
&lt;p>(Page.732)对于格式化的基本原理，好的布局凸显程序的逻辑结构。&lt;/p>
&lt;/blockquote>
&lt;p>好的代码书写能够更好的帮助我们阅读代码。我想但凡读过牛人写的代码的同学，应该会有所体会。&lt;/p>
&lt;p>我记得当我刚开始写程序的时候，那个时候但凡看见一个程序写的熟练的人都非常的羡慕。曾经也多次感慨，啥时候咱也能像人家那样，熟练的写代码呢？&lt;/p>
&lt;p>那么什么才是好布局呢？或者说良好布局的目标是什么呢？书中列出了几条(Page.735)，&lt;/p>
&lt;ul>
&lt;li>准确表现代码的逻辑结构&lt;/li>
&lt;li>始终如一地表现代码的逻辑结构。&lt;/li>
&lt;li>改善可读性&lt;/li>
&lt;li>经得起修改&lt;/li>
&lt;/ul>
&lt;p>关于布局技术一节，提到「空白」、和「括号」。对于空白的使用，主要包括分组、空行、缩进等方式。括号就不用多说了，对于容易引起奇异的地方，最好用括号予以区分。一方面可以避免错误。另一方面增加可读性。&lt;/p>
&lt;p>代码的布局风格，主要分为「纯块结构」、「模仿纯块结构」、「使用begin-end对(花括号)指定块边界」、「行尾布局」。下面针对不同的风格，摘录一些代码示例进行展示。&lt;/p>
&lt;ul>
&lt;li>纯块布局(Page.738)&lt;/li>
&lt;/ul>
&lt;p>&lt;em>(Page.739)纯if块的Visual Basic示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-vb" data-lang="vb">&lt;span class="line">&lt;span class="cl">&lt;span class="k">If&lt;/span> &lt;span class="n">pixelColor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Color_Red&lt;/span> &lt;span class="k">Then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">End&lt;/span> &lt;span class="k">If&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.739)纯while块的Visual Basic示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-vb" data-lang="vb">&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">pixelColor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Color_Red&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">Wend&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.739)纯case块的Visual Basic示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-vb" data-lang="vb">&lt;span class="line">&lt;span class="cl">&lt;span class="k">Select&lt;/span> &lt;span class="k">Case&lt;/span> &lt;span class="n">pixelColor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="n">Color_Red&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="n">Color_Green&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="k">Else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">End&lt;/span> &lt;span class="k">Select&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>模仿纯块结构&lt;/li>
&lt;/ul>
&lt;p>&lt;em>(Page.741)模仿纯if块的C++示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">Color_Red&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.741)模仿纯while块的C++示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">Color_Red&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.741)模仿纯switchcase块的C++示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nl">Color_Red&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nl">Color_Green&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>​&lt;/p>
&lt;ul>
&lt;li>使用begin-end对(花括号)指定块边界 &lt;br>
&lt;em>(Page.742)使用begin和end作为if块边界的C++例子&lt;/em>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">Color_Red&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.742)使用begin和end作为while块边界的C++例子&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">Color_Red&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.743)使用begin和end作为switch/case代码块边界的C++例子&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nl">Color_Red&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">case&lt;/span> &lt;span class="nl">Color_Green&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>行尾布局
&lt;em>(Page.744)Visual Basic中较少见但看上去相当好的行尾布局示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">If&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">soldCount&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">Then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">markdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">profit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.05&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">markdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.05&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">End&lt;/span> &lt;span class="n">If&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.744)Visual Basic使用行尾布局的while代码块示例&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">While&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelColor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Color_Red&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">statement2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Wend&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;em>(Page.744)更典型的Visual Basic示例，其行尾布局已失去应有的作用&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">If&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">soldCount&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="n">And&lt;/span> &lt;span class="n">prevMonthSales&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">Then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">If&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">soldCount&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="n">And&lt;/span> &lt;span class="n">prevMonthSales&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">Then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">If&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">soldCount&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">Then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">markdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">profit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.05&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">markdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.05&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">End&lt;/span> &lt;span class="n">If&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">markdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.025&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">End&lt;/span> &lt;span class="n">If&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">markdown&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">End&lt;/span> &lt;span class="n">If&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>好啦，列举了这么多的格式，到底那种风格最好呢？书中并没有给出答案，&lt;/p>
&lt;blockquote>
&lt;p>(Page.745)所有风格都不绝对可靠，都偶尔需要进行“合理而明显”的折中。&lt;/p>
&lt;/blockquote>
&lt;p>随后书中对一些常见代码书写结构给出了一些建议。例如，&lt;/p>
&lt;blockquote>
&lt;p>(Page.758))每行仅写一条语句&lt;/p>
&lt;/blockquote>
&lt;p>并针对此条语句给出了一些很有说服力的理由。对于数据声明的布局，和语句一样，也是每行只声明一个数据。这些理解起来都比较容易，在这里就不罗列代码了。&lt;/p>
&lt;p>对于注释的布局也同样重要，注释写的好，也可以大大增进程序的可读性。我记得在我刚开始写代码的时候，增经有一段时期非常喜欢写注释，几乎每一行都要加上注释，以显得很专业，:D。其实，后来看书才了解到，什么应该写注释，什么时候没必要写。有时候不必要的注释让人看起来很冗余。反而会影响代码的阅读。&lt;/p>
&lt;p>子程序的布局原则主要包括两个方面(Page.766)，&lt;/p>
&lt;ul>
&lt;li>用空行分割子程序的各部分&lt;/li>
&lt;li>将子程序参数按标准缩进&lt;/li>
&lt;/ul>
&lt;p>类的布局分为两部分，一部分是类接口的布局，另一类是类实现的布局。类接口布局时，一般按如下顺序表示(Page.768)：&lt;/p>
&lt;ol>
&lt;li>说明类及其完整用法的头部注释&lt;/li>
&lt;li>构造函数与析构函数&lt;/li>
&lt;li>public子程序&lt;/li>
&lt;li>protected子程序&lt;/li>
&lt;li>private子程序和数据成员&lt;/li>
&lt;/ol>
&lt;p>类实现的布局，通常按如下顺序排布(Page.768~769)：&lt;/p>
&lt;ol>
&lt;li>描述类所在文件之内容的头部注释&lt;/li>
&lt;li>类数据&lt;/li>
&lt;li>public子程序&lt;/li>
&lt;li>protected子程序&lt;/li>
&lt;li>private子程序&lt;/li>
&lt;/ol>
&lt;p>书中也对文件和程序布局给出了一些建议(Page.771)，&lt;/p>
&lt;ul>
&lt;li>一个文件应只有一个类&lt;/li>
&lt;li>文件的命名应该与类有关&lt;/li>
&lt;li>在文件中清晰地分隔各子程序&lt;/li>
&lt;li>按字母顺序排列子程序&lt;/li>
&lt;/ul>
&lt;h2 id="第三十二章自说明代码">第三十二章——自说明代码&lt;/h2>
&lt;p>本章主要将了程序中注释相关问题。但是本章在一开始就表明了注释的态度。例如，&lt;/p>
&lt;blockquote>
&lt;p>(Page.778)在代码层文档中起主要作用的因素并非注释，而是好的编程风格。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>(Page.779)对于精心编写的代码而言，注释不过是美丽衣裳上的小饰物而已。&lt;/p>
&lt;/blockquote>
&lt;p>其实，这两句话的意思是说，再清晰的注释也比不过简单明了的代码。对于什么情况下需要写注释，书中并没有给出定义，但是用了一段程序员之间的对话进行了表述。&lt;/p>
&lt;p>对于注释的作用共分为六种(Page.786)，&lt;/p>
&lt;ul>
&lt;li>重复代码&lt;/li>
&lt;li>解释代码&lt;/li>
&lt;li>代码标记&lt;/li>
&lt;li>概述代码&lt;/li>
&lt;li>代码意图说明&lt;/li>
&lt;li>传达代码无法表达的信息&lt;/li>
&lt;/ul>
&lt;p>随后书中提到，&lt;/p>
&lt;blockquote>
&lt;p>(Page.788)对于完工的代码，只允许有的三种注释类型：代码无法表述的信息、目的性注释和概述性注释。&lt;/p>
&lt;/blockquote>
&lt;p>关于高效的注释，书中给出了几条指导原则(Page.788~Page.791)，&lt;/p>
&lt;ul>
&lt;li>采用不会打断或抑制修改的注释风格&lt;/li>
&lt;li>用伪代码编程法减少注释时间&lt;/li>
&lt;li>将注释继承到你的开发风格中&lt;/li>
&lt;li>性能不是逃避注释的好借口&lt;/li>
&lt;/ul>
&lt;p>代码的注释技术分为两种，一种是单行注释。另一种是多行注释。在解释单/多行注释的过程中，分别说了注释数据和单/多行语句的方式，并通过一些小的代码片段简要说明了哪些注释会带来问题。这些小片段写的都很繁琐，所以这里也就不列举了，说一下这些注释的共性，很简单，就是繁琐。原因更多的是想让代码看起来美观，但却给维护带来了较高的成本。&lt;/p>
&lt;h2 id="第三十三章个人性格">第三十三章——个人性格&lt;/h2>
&lt;p>说实话，看完这章的整体感受是，对于以写程序为生，似乎又看到了一丝的光明&amp;hellip;&amp;hellip;
这里列举一些书中提到的经验。有些给了我很大的启发，对自己以后的规划起到了一些借鉴作用。&lt;/p>
&lt;blockquote>
&lt;p>(Page.821)如何专注你的聪明才智，比你有多聪明更重要。&lt;/p>
&lt;/blockquote>
&lt;p>对于这句话，我觉得之前我走了不少弯路。前几年做的工作大多比较零散，坦白说没有往深度做，也没有这样的机会。当然了，主要原因还是在自己没有意识到这一点吧。我想以后，我会专注一些，把精力放到自己感兴趣的技术上来。&lt;/p>
&lt;blockquote>
&lt;p>(Page.821)精通编程的人是那些了解自己头脑有多大局限性的人，都很谦虚&lt;/p>
&lt;/blockquote>
&lt;p>这一点，我觉得前几年我做的还不够。有的时候，回头想想我可能过于自信了，其实可能是因为太自卑了，所以才要表现的很自信吧。&lt;/p>
&lt;p>对于求知欲这部分，有一段话讲的很好，&lt;/p>
&lt;blockquote>
&lt;p>(Page.822)一旦承认自己的脑袋要理解多数程序还有难度，并意识到有效的编程就是去追寻改善这一境况的方式时，你就会开始需要付毕生精力的漫长求索过程。在成为高手的过程中，对技术的事物的求知欲具有压倒一切的重要性。&lt;/p>
&lt;/blockquote>
&lt;p>对于这段话来说，我发现我做的还差很多，虽然我早发现自己技术上差的还很多，但是我不知道能不能用毕生的精力去追求，我想我能做的就是尽自己最大的努力。&lt;/p>
&lt;blockquote>
&lt;p>(Page.823)学习编程的一个特别好的途径是研究高手的程序。&lt;/p>
&lt;/blockquote>
&lt;p>这一点在很多高手的经验之谈中经常会看到。所谓的捷径，我想也就是这个吧，:)。&lt;/p>
&lt;blockquote>
&lt;p>(Page.826)拒绝认错是一个让人特别讨厌的习惯。&lt;/p>
&lt;/blockquote>
&lt;p>现实中，见过很多这样的朋友。大部分原因可能是因为面子吧，呵呵。对于这一点，貌似全世界的程序员都有这个通病，只不过有的人比较坦诚，有的人比较猥琐。我自己觉得，但凡是坦诚认错的人，更表明了他有信心。拉不下脸来认错的人，其实是没有自信的表现，最后可能让自己错过纠正错误的机会，其实是不明智的表现。&lt;/p>
&lt;p>书中有一段在讲&lt;!-- raw HTML omitted -->经验&lt;!-- raw HTML omitted -->。我很认可其中的观点，&lt;/p>
&lt;blockquote>
&lt;p>(Page.831)与其他行业相比，软件开发行业的经验比书本知识价值要小，&amp;hellip;。&lt;/p>
&lt;/blockquote>
&lt;p>这一点比较好理解，但是不容易被大多数行业内的人接受，这需要时间慢慢转变。&lt;/p>
&lt;h2 id="第三十四章软件工艺的话题">第三十四章——软件工艺的话题&lt;/h2>
&lt;blockquote>
&lt;p>(Page.837)致力于降低复杂度是软件开发的核心。&lt;/p>
&lt;/blockquote>
&lt;p>我想这一句话总结了本书的主旨。本书的所有章节都是在围绕这个话题展开，:)。本章后面讲的就不多说了，基本上属于总结性的话题。&lt;/p>
&lt;h2 id="第三十五章何处有更多信息">第三十五章——何处有更多信息&lt;/h2>
&lt;p>呵呵，题目很清楚。本章列出了一些不同阶段程序员可以参考的资料。这里就不多说了。&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（六）</title><link>https://ohcoder.com/post/2013/04/14/reading-code-complete6/</link><pubDate>Sun, 14 Apr 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/04/14/reading-code-complete6/</guid><description>&lt;img src="https://ohcoder.com/post/2013/04/14/reading-code-complete6/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（六）" />&lt;p>本周读了本书的第六部分，此部分的主题为系统考虑。本部分分为四个章节，分别描述了程序规模对构建软件的影响，对构建的管理，系统的集成，以及相关的编程工具。&lt;/p>
&lt;p>还是老样子，下面对每一章的内容进行简要的摘录。&lt;/p>
&lt;h2 id="第二十七章程序规模对构建的影响">第二十七章——程序规模对构建的影响&lt;/h2>
&lt;p>本章开始描述了交流与规模的关系，提出&lt;/p>
&lt;blockquote>
&lt;p>(Page.650)&amp;hellip;二者的关系并不是加性的而是乘性的。即交流路径的条数大致正比于人数的平方。&lt;/p>
&lt;/blockquote>
&lt;p>根据项目规模的不同，会对错误产生不同的影响。&lt;/p>
&lt;blockquote>
&lt;p>(Page.651)项目的规模既会影响错误的数量，也会影响错误的类型。&lt;/p>
&lt;/blockquote>
&lt;p>坦白说，这句话中所说的项目规模会对错误数量产生影响很自然可以想到，但是说也会影响错误的类型，我之前是没有想到的。&lt;/p>
&lt;p>书中谈到项目规模对生产率影响一节时，引用到这样一句话，我觉得对于移动互联网的开发也是蛮适合的。这句话是这样说的&lt;/p>
&lt;blockquote>
&lt;p>(Page.653)&amp;hellip;，完成项目的小型团队的生产率摇臂大型团队高出 39%，那么这些团队各有多少人呢？答案是，小项目两个人，大项目三个人(1984)。&lt;/p>
&lt;/blockquote>
&lt;p>之前看《&lt;!-- raw HTML omitted -->打造Facebook&lt;!-- raw HTML omitted -->》那本书的时候，作者提到在 Facebook 内部开发一个新项目，一般人数也很少。例如他自己主导开发的那个项目，一开始也只有三个人。&lt;/p>
&lt;p>对于项目规模对开发活动的影响一节中，文中指出&lt;/p>
&lt;blockquote>
&lt;p>(Page.655)规模相近的项目会执行相似的活动，但是随着项目规模不同，其所需要进行的活动的种类也会有明显的差异。&lt;/p>
&lt;/blockquote>
&lt;p>最后谈论了一下不同级别的规模与方法论之间的关系。其实，本章讲的都比较概括，不过中心思想很明确，主要就是描述了因为程序规模的不同对于构建软件不同方面的影响。&lt;/p>
&lt;h2 id="第二十八章管理构建">第二十八章——管理构建&lt;/h2>
&lt;p>本章主要讲了对于软件开发过程中的项目管理。&lt;/p>
&lt;p>在编码方面，提出了一些建议，其中对于定制标准方面，书中给出了一条建议，我觉得可以直接用于实践，&lt;/p>
&lt;blockquote>
&lt;p>(Page.662)如果项目中有人要制定标准，那么应该由一位受人尊敬的架构师来做，而不应该由管理者来做。在软件项目中，“专家层”起的作用至少与“管理层”相同。&lt;/p>
&lt;/blockquote>
&lt;p>其实，像这种直接面向技术层面的问题，管理者或许没有资深的技术人员更专业。对于良好的编码实践要比呆板的标准更容易实行。书中给出了几条建议(Page.662~Page.664)。&lt;/p>
&lt;ul>
&lt;li>给项目的每一部分分派两个人&lt;/li>
&lt;li>逐行复查代码&lt;/li>
&lt;li>要求代码签名&lt;/li>
&lt;li>安排一些好的代码示例供人参考&lt;/li>
&lt;li>强调代码是公有财产&lt;/li>
&lt;li>奖励好代码&lt;/li>
&lt;li>一份简单的标准&lt;/li>
&lt;/ul>
&lt;p>上面的建议的好处也比较明显，就不展开说了。&lt;/p>
&lt;p>接下来讲到配置管理，什么是配置管理？&lt;/p>
&lt;blockquote>
&lt;p>(Page.664)配置管理是 “系统化地定义项目工件(project arifacts)和处理变化，以使项目一直保持其完整性” 的实践活动。它的另一种说法是“变更控制”。其中的技术包括评估所提交的更改、追踪更改、保留系统在不同时间点的各历史版本。&lt;/p>
&lt;/blockquote>
&lt;p>对于构建过程中需求的变更和设计的变更，书中给出了一种方法是，&lt;/p>
&lt;blockquote>
&lt;p>(Page.666)&amp;hellip;，记下所有的想法和建议，不管它实现起来有多容易。把它记录下来，直到你有时间去处理它们。到那时，把它当做整体(group)来看待，从中选中最有益的一些变更来加以实施。&lt;/p>
&lt;/blockquote>
&lt;p>即便如此，对于软件的变更也会是一大难题。估计很多朋友都在网上看到过一些有趣的漫画，内容大概是项目经理让程序员不停的改动需求，直到程序员崩溃&amp;hellip;。书中对此现象的评价说&lt;/p>
&lt;blockquote>
&lt;p>(Page.667)缺乏规范的变更控制是当今软件业面临的主要管理难题之一。&lt;/p>
&lt;/blockquote>
&lt;p>看来，变更是一个世界性的难题，呵呵。&lt;/p>
&lt;p>对于软件代码变更的管理，书中提到了版本管理软件的使用。版本管理软件不但可以有效的管理代码变更，还可以对代码起到备份的作用，不会轻易丢失代码。&lt;/p>
&lt;p>对于评估构建的进度方面，书中提到了一些评估项目的方法(Page.671~Page.672)。&lt;/p>
&lt;ul>
&lt;li>建立目标&lt;/li>
&lt;li>为评估留出时间，并且做出计划&lt;/li>
&lt;li>清楚地说明软件需求&lt;/li>
&lt;li>在底层细节层面进行评估&lt;/li>
&lt;li>使用若干不同的评估方法，并且比较其结果&lt;/li>
&lt;li>定期做重新评估&lt;/li>
&lt;/ul>
&lt;p>具体就不展开说了，都比较容易理解。&lt;/p>
&lt;p>对于项目进度影响最大的原因是&lt;/p>
&lt;blockquote>
&lt;p>(Page.674)&amp;hellip;所开发的程序的规模。&lt;/p>
&lt;/blockquote>
&lt;p>这一点很容易理解，呵呵。&lt;/p>
&lt;p>在度量这一节中，文中提出了对项目进行度量的两个根本原因。&lt;/p>
&lt;ul>
&lt;li>(Page.677)任何一种项目特征(attribute)都是可以用某种方法来度量的，而且总会比根本不度量好得多。&lt;/li>
&lt;li>(Page.678)反对度量就是认为最好不要去了解项目中到底在发生什么。&lt;/li>
&lt;/ul>
&lt;p>其实，关于度量，我自己的理解是，需要有一个大致的标尺来丈量项目的进度，但也不应该过于依赖这种度量，要张弛有度，保证项目不偏离大方向。&lt;/p>
&lt;p>本章后面部分讲述了一些管理方面的经验。例如如何和你的管理者沟通等等。其中有很多建议实践性很强，并且针对性也很强，需要有相应的环境为基础，所以在此就不罗列了，没太大意义。&lt;/p>
&lt;h2 id="第二十九章集成">第二十九章——集成&lt;/h2>
&lt;p>本章讲述了几种软件集成的方式，但各有利弊，无银弹。&lt;/p>
&lt;p>对于集成的方式，分为两种：阶段式集成和增量集成。&lt;/p>
&lt;p>首先从阶段式集成开始介绍。阶段式集成的另一个名称是“大爆炸集成”。阶段式集成面临的问题，摘用书中的一句话描述，&lt;/p>
&lt;blockquote>
&lt;p>(Page.691)阶段式集成的一个问题是，当第一次把系统中的类放到一起时，新的问题会不可避免地大量浮现，而问题的成因可能是方方面面的。&lt;/p>
&lt;/blockquote>
&lt;p>书中说，对于&lt;/p>
&lt;blockquote>
&lt;p>(Page.692)&amp;hellip;，对微型程序——而言，阶段式集成或许是最佳方式。&lt;/p>
&lt;/blockquote>
&lt;p>其实也可以看出，阶段式集成非常的不常用。下面介绍增量集成。&lt;/p>
&lt;p>在增量集成中，可以一次一块地将程序模块拼接起来。对于增量集成的好处，书中列出了几条(Page.693~Page.694)：&lt;/p>
&lt;ul>
&lt;li>易于定位错误&lt;/li>
&lt;li>及早在项目里取得系统级的成果&lt;/li>
&lt;li>改善进度的监控&lt;/li>
&lt;li>改善客户关系&lt;/li>
&lt;li>更加充分地测试系统中的各个单元&lt;/li>
&lt;li>能在更短的开发进度计划内建造出整个系统&lt;/li>
&lt;/ul>
&lt;p>其实，我感觉这些条条框框基本上也记不太准确，可以作为参考吧。对于增量集成的策略，书中提到了几种，下面一一说明。&lt;/p>
&lt;p>自顶向下集成&lt;/p>
&lt;p>故名思义，在自顶向下的集成中，首先编写并集成位于层次体系(hierachy)顶部的类。此种策略，除了具有增量集成的一般优点以外，能相对较早地测试系统的控制逻辑，能够在项目早期完成一个能部分工作的系统。&lt;/p>
&lt;p>但是除了优点以外，当然还有缺点，在纯粹的自顶向下集成将棘手的系统接口的演练留到最后才进行。书中给出的最终意见是&lt;/p>
&lt;blockquote>
&lt;p>(Page.696)实现纯粹的自顶向下集成也是近乎不可能的。&lt;/p>
&lt;/blockquote>
&lt;p>自底向上集成&lt;/p>
&lt;p>在自底向上的集成中，需要先编写集成位于hierarchy底部的类。关于这种方法的优缺点，书中说&lt;/p>
&lt;blockquote>
&lt;p>(Page.697)它能讲错误的可能来源限制到“正在被集成的那一个类”上，因此容易定位错误。&lt;/p>
&lt;/blockquote>
&lt;p>但同样，缺点是&lt;/p>
&lt;blockquote>
&lt;p>(Page.697)它将重要的高层系统接口集成工作留到最后才进行。&lt;/p>
&lt;/blockquote>
&lt;p>三明治集成&lt;/p>
&lt;p>关于这种方法，&lt;/p>
&lt;blockquote>
&lt;p>(Page.698)首先是集成层次体系(hierachy)顶部的高层业务对象(business-object)类。然后集成底部的与设备接口的类和广泛使用的工具类。这些高层类和底层类是三明治的那两片面包。&lt;/p>
&lt;/blockquote>
&lt;p>这种集成方法避免了纯粹的自底向上或自顶向下集成的僵化做法。先集成通常比较棘手的类，降低了后期的风险。&lt;/p>
&lt;p>风险导向的集成&lt;/p>
&lt;p>风险导向的集成也称为“困难部件优先集成”。它和三明治集成类似，也是趋向于先集成顶层类和底层类，讲中间层类留后处理，但是它们的出发点不同。其实不同点主要就在于，风险导向的集成偏向与先把风险高的部件进行集成。&lt;/p>
&lt;p>功能导向的集成&lt;/p>
&lt;p>顾名思义，也就是一次集成一项功能。&lt;/p>
&lt;blockquote>
&lt;p>(Page.701)纯碎的功能导向的集成和纯碎的自顶向下或自底向上集成一样苦难。通常需要先集成某些底层的代码，之后才能集成某些重要的功能。&lt;/p>
&lt;/blockquote>
&lt;p>T—型集成&lt;/p>
&lt;p>对于这种集成方法，是选中某个特定的“竖直块/vertical slice”，对它及早开发并进行集成。对于这个功能模块，是从头到尾的进行完成，而且过程中应该能找出系统设计所做的假设中的全部主要问题。这种方法，通常和“风险导向的集成”或“功能导向的集成”结合使用。&lt;/p>
&lt;p>本章最后，还提到了两种方法，一种是daily build，另一种是冒烟测试。对于这两种方法就不展开说了。&lt;/p>
&lt;h2 id="第三十章编程工具">第三十章——编程工具&lt;/h2>
&lt;p>从标题也可以看出，本章主要围绕着工具展开，其中包括设计工具、代码管理工具、编程工具等。整个章节大概翻了一下，基本都是介绍性的说明了一下功能，或者是作用等，这里就不多说了，没有太大的意义，因为每个人的工作习惯都不一样，而且随着时间的推移，很多工程上的方法也都在不断的变化，所以感觉这部分没有太大的参考价值。&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（五）</title><link>https://ohcoder.com/post/2013/04/07/reading-code-complete5/</link><pubDate>Sun, 07 Apr 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/04/07/reading-code-complete5/</guid><description>&lt;img src="https://ohcoder.com/post/2013/04/07/reading-code-complete5/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（五）" />&lt;p>本书的第五部分讲的主题为 &lt;strong>代码改善&lt;/strong>。&lt;/p>
&lt;p>这一部分总共包括七章，从软件开发的不同阶段以及不同角度进行了描述，当然了，中心就是 &lt;strong>代码改善&lt;/strong> 代码的构建、开发者测试、调试、重构以及代码的调整等不同方面进行了讲述。&lt;/p>
&lt;p>下面还是对每一章内容做一个简要的总结。&lt;/p>
&lt;h2 id="第二十章软件质量概述">第二十章——软件质量概述&lt;/h2>
&lt;p>顾名思义，从本章的题目中也可以看出，本章主要是对软件质量做了一个概括，大概描述了一下软件质量都包括哪些方面。&lt;/p>
&lt;p>关于软件质量的特性，书中描述说，软件同时拥有外在的和内在的质量特性。软件的外在特性包括(Page.463~Page.464)，&lt;/p>
&lt;ul>
&lt;li>正确性(Correctness)&lt;/li>
&lt;li>可用性(Usability)&lt;/li>
&lt;li>效率(Efficiency)&lt;/li>
&lt;li>可靠性(Reliability)&lt;/li>
&lt;li>完整性(Integrity)&lt;/li>
&lt;li>适应性(Adaptability)&lt;/li>
&lt;li>精确性(Accuracy)&lt;/li>
&lt;li>健壮性(Robustness)&lt;/li>
&lt;/ul>
&lt;p>软件的内在特性包括(Page.464~Page.465)&lt;/p>
&lt;ul>
&lt;li>可维护性(Maintainability)&lt;/li>
&lt;li>灵活性(Flexibility)&lt;/li>
&lt;li>可移植性(Portability)&lt;/li>
&lt;li>可重用性(Reusability)&lt;/li>
&lt;li>可读性(Readability)&lt;/li>
&lt;li>可测试性(Testability)&lt;/li>
&lt;li>可理解性(Understandability)&lt;/li>
&lt;/ul>
&lt;p>对于外在特性，一部分特性有互相重叠，但有不同的含义，在不同场合侧重点也不一样。相应的，内在特性也是如此。而且内在特性和外在特性之间也不能完全割裂开。关于这一点，我觉得也是很显然的事情，内在的状态会对外在形成影响，外在的表现又会对内在提出要求。&lt;/p>
&lt;p>随后，书中说到在哪些方面可以改善软件质量(Page.466~Page.467)。&lt;/p>
&lt;ul>
&lt;li>软件质量目标&lt;/li>
&lt;li>明确定义质量保证工作&lt;/li>
&lt;li>测试策略&lt;/li>
&lt;li>软件工程指南&lt;/li>
&lt;li>非正式计数复查&lt;/li>
&lt;li>正式计数复查&lt;/li>
&lt;li>外部审查&lt;/li>
&lt;/ul>
&lt;p>接下来，书中列举了一些数据，用来表明不同质量保障技术的效能。我觉得吧，这些数据看看就可以了，因为作者那个年代的移动互联网基本上还没成型，所以这些数据我觉得对于移动互联网并不一定适用，反而对于传统的大型桌面应用可能更适用一些，不过不管怎么说，对于移动互联网这个新型行业而言，去其糟粕，取其精华就好，死搬硬套要不得。&lt;/p>
&lt;p>下面说到什么时候应该进行质量保证工作，书中的观点是说，从软件开始构建这个工作就开始了，我觉得这个观点很好，因为构建软件是一项工程，分为不同的阶段，哪一个阶段都应该保证质量，而且越早引入缺陷越晚发现，成本就越高，所以说质量保证工作从前期准备阶段就开始了。随后书中有这样一句话，我产生了一点感想，&lt;/p>
&lt;blockquote>
&lt;p>(Page.475)&amp;hellip;，因此把时间投入到前期工作中，能让程序员在后期工作中节省更多的时间。这一方法的最终效果是软件的缺陷更少，开发时间更短，成本也更低。&lt;/p>
&lt;/blockquote>
&lt;p>看到这段话之后，我觉得对于做移动互联网开发来说，或许不太合适，因为目前很多移动互联网开发方面的应用属于试探性的开发方式，基本上测试、设计以及开发是交织在一起的。但是抛开这一点不谈，我觉得这句话从侧面也说明了一点，对于传统桌面应用来说，这种方法是在尽可能的压缩编码时间，说句大白话就是把所有设计都做好，编码只是个体力活。很明显，这种方式可以降低编写代码的出错率，保证了软件的质量，从另一方面，我也意识到，软件开发的设计阶段真的很重要。当然了，对于移动互联网的开发来说，这种方式实施起来未免会觉得有些教条。&lt;/p>
&lt;h2 id="第二十一章协同构建">第二十一章——协同构建&lt;/h2>
&lt;p>本章对结对编程做了介绍，及其好处。随后对代码审查的方法进行了描述，并对如何做审查做了说明，最后还介绍了几种其他类型的协同开发方法。&lt;/p>
&lt;p>关于结对编程，说实话，我没有实践过，也不知道是什么样的一种感受，不过倒是可以想象一下，呵呵。对于成功运用结对编程的关键点，书中提到了几点(Page.483~Page.484)，&lt;/p>
&lt;ul>
&lt;li>用编码规范来支持结对编程&lt;/li>
&lt;li>不要让结对编程编程旁观&lt;/li>
&lt;li>不要强迫在简单的问题上使用结对编程&lt;/li>
&lt;li>有规律地对结对人员和分配地工作任务进行轮换&lt;/li>
&lt;li>鼓励双方跟上对方的步伐&lt;/li>
&lt;li>确认两个人都能够看到显示器&lt;/li>
&lt;li>不要强迫程序员与自己关系紧张的人组对&lt;/li>
&lt;li>避免新手组合&lt;/li>
&lt;li>指定一个组长&lt;/li>
&lt;/ul>
&lt;p>其实对于这些关键点，我想联想一下都能理解其中的意思，无非都是以人为中心提出的一些建议，让两个结对编程的人能够默契，避免沟通上的一些不畅快。其实我觉得上面这些都不是问题，你想啊，如果一个是MM一个是GG，那么我觉得这些都不是问题鸟，哈哈。开个玩笑，轻松一下。&lt;/p>
&lt;p>对于详查(正式审查)，书中提出了一些方法。比如说，详查人员需要哪些角色。说白了，其实就是代码的 &lt;!-- raw HTML omitted -->review&lt;!-- raw HTML omitted -->，然后大家坐在一起开会探讨。对于其中的角色，文中列出了五种(Page.486)，&lt;/p>
&lt;ul>
&lt;li>主持人&lt;/li>
&lt;li>作者&lt;/li>
&lt;li>评论员(reviewer)&lt;/li>
&lt;li>记录员&lt;/li>
&lt;li>经理&lt;/li>
&lt;/ul>
&lt;p>&lt;!-- raw HTML omitted -->主持人&lt;!-- raw HTML omitted -->其实就是管理详查这个事儿的，保证一定的进度。&lt;!-- raw HTML omitted -->作者&lt;!-- raw HTML omitted -->就是码农本人。&lt;!-- raw HTML omitted -->评论员&lt;!-- raw HTML omitted -->就是审查代码的人，&lt;!-- raw HTML omitted -->记录员&lt;!-- raw HTML omitted -->就是记录问题的人。&lt;!-- raw HTML omitted -->经理&lt;!-- raw HTML omitted -->就不用多说了，就是软件项目的负责人。文中有一条建议我觉得是保证顺利实施的关键一点，&lt;/p>
&lt;blockquote>
&lt;p>(Page.487)类似的，无论在任何情况下，详查的结果都不应当作为员工表现的评估标准，这种杀鸡取卵的行为不可取。在详查中被检验的代码仍处于开发阶段。对员工表现的评价应当基于最终产品，而不是尚未完成的工作。&lt;/p>
&lt;/blockquote>
&lt;p>关于参与这种审查的人数，作者建议一般不少于三人。随后对具体实施审查的方法进行了描述，这里就不多说了，感觉操作性很强，干巴巴的口头描述实在是有点枯燥。&lt;/p>
&lt;p>最后在其他类型的协同开发实践中，作者提到&lt;!-- raw HTML omitted -->走查&lt;!-- raw HTML omitted -->。对于走查，引用书中的一段话描述，&lt;/p>
&lt;blockquote>
&lt;p>(Page.492)走查是一种很流行的复查方式，这个词的定义很随意，其流行在于某种程度上，人们把任何形式的复查都称为“走查”。&lt;/p>
&lt;/blockquote>
&lt;h2 id="第二十二章开发者测试">第二十二章——开发者测试&lt;/h2>
&lt;p>本章的一开始，介绍常见的测试方式，并给出了简要的解释(Page.499~Page.500)。&lt;/p>
&lt;ul>
&lt;li>单元测试(Unit testing)是将一个程序员或者一个开发团队所编写的，一个完整的类、子程序或者小程序，从完整的系统中隔离出来进行测试。&lt;/li>
&lt;li>组件测试(Component testing)是将一个类、包、小程序或者其他程序元素，从一个更加完成的系统中隔离出来进行测试，这些被测试代码涉及到多个程序员或者多个团队。&lt;/li>
&lt;li>集成测试(Integration testing)是对两个或更多的类、包、组件或者子系统进行的联合测试，这些组件由多个程序员或者开发团队所创建。这种测试通常在有了两个可以进行测试的类的时候就应该尽快开始，并且一直持续到整个系统开发完成。&lt;/li>
&lt;li>回归测试(Regression testing)是指重复执行以前的测试用例，以便在原先通过了相同测试集合的软件中查找缺陷。&lt;/li>
&lt;li>系统测试(System testing)是在最终的配置下(包括同其他软硬件系统的集成)运行整个软件。以便测试安全、性能、资源消耗、时序方面的问题，以及其他无法在低级集成上测试的问题。&lt;/li>
&lt;/ul>
&lt;p>关于测试的类型，通常分为两大类：黑盒测试(black-box testing)和白盒测试(white-box,或者玻璃盒glass-box)测试。&lt;/p>
&lt;p>对于开发者测试来说，书中提到了几种推荐的方法(Page.503)。&lt;/p>
&lt;ul>
&lt;li>对每一项相关的需求进行测试，以确保需求都已经被实现。&lt;/li>
&lt;li>对每一个相关的设计关注点进行测试，以确保设计已经被实现。&lt;/li>
&lt;li>用基础测试(basis testing)来扩充针对需求和设计的详细测试用例。&lt;/li>
&lt;li>使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型。&lt;/li>
&lt;/ul>
&lt;p>这些测试方法，我觉得还是需要根据实际情况去掌握吧，因为我觉得这些方法主要还是针对于大型桌面软件来说的，对于如今的移动互联网来说，我觉得仅能起参考价值。&lt;/p>
&lt;p>对于先写测试还是后写测试，作者推荐还是先写测试。文中说，&lt;/p>
&lt;blockquote>
&lt;p>(Page.503)首先写测试用例可以将从引入缺陷到发现并排除缺陷之间的时间缩减至最短。&lt;/p>
&lt;/blockquote>
&lt;p>对于开发者测试，文中提到了一些局限性，这些局限性对于我来说，我觉得还是蛮准的(Page.504)。&lt;/p>
&lt;ul>
&lt;li>开发者测试倾向于“干净测试”&lt;/li>
&lt;li>开发者测试对于覆盖率有过于乐观的估计&lt;/li>
&lt;li>开发者测试往往回忽略一些更复杂的测试覆盖率类型&lt;/li>
&lt;/ul>
&lt;p>在测试技巧这一节，文中提到几种测试类型。例如，&lt;/p>
&lt;ul>
&lt;li>(Page.505)结构化基础测试。&lt;/li>
&lt;li>(Page.509)数据流测试。&lt;/li>
&lt;/ul>
&lt;p>本章后面提到了几种测试支持工具。&lt;/p>
&lt;ul>
&lt;li>(Page.524)Diff工具&lt;/li>
&lt;li>(Page.524)测试数据生成器&lt;/li>
&lt;li>(Page.526)覆盖率监视器&lt;/li>
&lt;li>(Page.526)数据记录器/日志记录器&lt;/li>
&lt;li>(Page.526)符号调试器&lt;/li>
&lt;li>(Page.527)系统干扰器&lt;/li>
&lt;li>(Page.527)错误数据库&lt;/li>
&lt;/ul>
&lt;p>说实在的，好多测试工具都木有接触过。算是长姿势，开眼界了。&lt;/p>
&lt;h2 id="第二十三章调试">第二十三章——调试&lt;/h2>
&lt;p>首先，对于调试在软件质量中扮演的角色，引用文中的一句话说是，&lt;/p>
&lt;blockquote>
&lt;p>(Page.536)同测试一样，调试本身并不是改进代码质量的方法，而是诊断代码缺陷的一种方法。&lt;/p>
&lt;/blockquote>
&lt;p>在效率低下的调试方法中，作者列举了几种常见的调试方法，在调试之魔鬼指南类型中，作者列举了几种常见错误的调试方法(Page.539)，&lt;/p>
&lt;ul>
&lt;li>凭猜测找到缺陷&lt;/li>
&lt;li>不要把时间浪费在理解问题上&lt;/li>
&lt;li>用最唾手可得的方式修正错误&lt;/li>
&lt;/ul>
&lt;p>我估计很多码农都有过这种想法吧，尤其是在压力大，时间紧迫的时候，哈哈。另外，作者还提到一种方式，叫迷信式调试。描述迷信式调试的这一段作者很幽默，一起欣赏下，&lt;/p>
&lt;blockquote>
&lt;p>(Page.539~Page.540)撒旦已慷慨地将地狱的某个部分租给那些在调试时怨天尤人的程序员了。每个团队里都也许有这样一个程序员，他总会遇到无穷的问题：不听话的及其，奇怪的编译器错误，月圆时才会出现的编程语言的隐藏缺陷，实效的数据，忘记做的重要改动，一个不能正常保存程序的疯狂的编辑器——你怎么描述这种行为好呢。这就是“迷信式编程(programming by superstition)”。&lt;/p>
&lt;/blockquote>
&lt;p>看到这一段，让我想起酷壳上一篇名为&lt;!-- raw HTML omitted -->《各种流行的编程风格》&lt;!-- raw HTML omitted -->的文章。好吧，我中枪了&amp;hellip;
在关于编译器给出语法错误方面，文中介绍了几种调试的方法(Page.549)，&lt;/p>
&lt;ul>
&lt;li>不要过分信任编辑器信息中的行号&lt;/li>
&lt;li>不要迷信编译器信息&lt;/li>
&lt;li>不要轻信编译器的第二条信息&lt;/li>
&lt;li>分而治之&lt;/li>
&lt;li>找出没有配对的注释或者引号&lt;/li>
&lt;/ul>
&lt;p>在修正错误的时候，文中给出了几种建议(Page.550~554)，&lt;/p>
&lt;ul>
&lt;li>在动手之前先要理解问题&lt;/li>
&lt;li>理解程序本身，而不仅仅是问题&lt;/li>
&lt;li>验证对错误的分析&lt;/li>
&lt;li>放松一下&lt;/li>
&lt;li>保存初始的源代码&lt;/li>
&lt;li>治本，而不是治标&lt;/li>
&lt;li>修改代码时一定要有恰当的理由&lt;/li>
&lt;li>一次只做一个改动&lt;/li>
&lt;li>检查自己的改动&lt;/li>
&lt;li>增加能暴露问题的单元测试&lt;/li>
&lt;li>搜索类似的缺陷&lt;/li>
&lt;/ul>
&lt;h2 id="第二十四章重构">第二十四章——重构&lt;/h2>
&lt;p>重构其实是一个很大的话题。本章对重构进行了简介，并从&lt;!-- raw HTML omitted -->特定的重构&lt;!-- raw HTML omitted -->，&lt;!-- raw HTML omitted -->安全的重构&lt;!-- raw HTML omitted -->以及&lt;!-- raw HTML omitted -->重构策略&lt;!-- raw HTML omitted -->三个方面做了讲解。对于什么情况下进行重构，文中给出了很多条重构的理由，找几条典型的记录下，&lt;/p>
&lt;ul>
&lt;li>(Page.565)冗长的子程序，在面向对象的编程中，很少会需要用到长度超过一个屏幕的子程序。&lt;/li>
&lt;li>(Page.567)数据成员被设置为公用&lt;/li>
&lt;li>(Page.568)在子程序调用前使用了设置代码(setup code)，或在调用后使用了收尾代码(takedown code)&lt;/li>
&lt;li>(Page.569)程序中的一些代码似乎是在将来的某个时候才会用到的&lt;/li>
&lt;/ul>
&lt;p>在特定重构一节，作者对不同层面的重构给出了相应的重构方法。具体都涉及到哪些层面，我想在此列一下，具体的方法就不说了，列出来可真就成了巨人的汗衫了(看过一点&lt;!-- raw HTML omitted -->《Window程序设计》&lt;!-- raw HTML omitted -->那本书的同学笑了)，呵呵。&lt;/p>
&lt;ul>
&lt;li>数据级的重构&lt;/li>
&lt;li>语句级的重构&lt;/li>
&lt;li>子程序级重构&lt;/li>
&lt;li>类实现的重构&lt;/li>
&lt;li>类接口的重构&lt;/li>
&lt;li>系统级重构&lt;/li>
&lt;/ul>
&lt;p>其实，我是觉得，对于这些不同层面的重构，其原则只有一个，就是&lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted -->原则。对于不同层级的重构，如果尽可能的保持&lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted -->原则，应该不会有大的偏差，只不过对于不同层级的重构，应用的方法不同而已。但我觉得书中提到的这些方法主要是起到了借鉴作用，还得要具体情况具体分析，似乎这句话听起来有点像废话，其实我的意思是，任何时候都不要太教条，世间没有什么救世主，哈哈。&lt;/p>
&lt;p>接下来是安全的重构。这部分主要是在提醒你，重构的时候要注意安全。其实最中心思想就是要避免在重构的过程中犯一些无法纠正的错误。关于这部分，文中也出了一些建议(Page.579~Page.581)，&lt;/p>
&lt;ul>
&lt;li>保存初始代码&lt;/li>
&lt;li>重构的步伐请小些&lt;/li>
&lt;li>同一时间只做一项重构&lt;/li>
&lt;li>把要做的事情一条条列出来&lt;/li>
&lt;li>设置一个停车场&lt;/li>
&lt;li>多使用检查点&lt;/li>
&lt;li>利用编译器警告信息&lt;/li>
&lt;li>重新测试&lt;/li>
&lt;li>增加测试用例&lt;/li>
&lt;li>检查对代码的修改&lt;/li>
&lt;li>根据重构风险级别来调整重构方法&lt;/li>
&lt;/ul>
&lt;p>这些建议细细品味觉得真的很受用，不过关键还是得根据自己的实际情况落实到实处哇。&lt;/p>
&lt;p>关于不宜重构的情况，文中指出，&lt;/p>
&lt;blockquote>
&lt;p>(Page.582)不要把重构当作先写后改的代名词。重构最大的问题在于被滥用。&lt;/p>
&lt;/blockquote>
&lt;p>我觉得可能很多人思想上就把重构当成了理所当然的补救措施，从而在开发阶段掉以轻心，降低了代码质量。另外一条是，&lt;/p>
&lt;blockquote>
&lt;p>(Page.582)避免用重构代替重写。&lt;/p>
&lt;/blockquote>
&lt;h2 id="第二十五章代码调整策略">第二十五章——代码调整策略&lt;/h2>
&lt;p>关于性能问题，作者说，&lt;/p>
&lt;blockquote>
&lt;p>(Page.587)你可以在两个层面考虑性能问题：策略上和技术上。&lt;/p>
&lt;/blockquote>
&lt;p>虽然是从两个层面进行考虑，不过本章只是从策略层面进行了讲解。&lt;/p>
&lt;p>首先，对代码调整做了简介，对其中的一些概念做了解释。例如Pareto法则，&lt;/p>
&lt;blockquote>
&lt;p>(Page.592)Pareto法则也就是众所周知的80/20法则。它讲述的是你可以用20%的努力取得80%的成绩。这一法则适用于程序设计之外的众多领域，它对程序优化也绝对有效。&lt;/p>
&lt;/blockquote>
&lt;p>这一点很重要。作者也用自己亲身经历的例子做了证明。很多时候，软件运行效率的低下并不是大部分代码有问题，而是一小部分代码出现了问题，只要找到那一小部分就可以对软件的优化起到决定性作用。对于优化，作者列出了一些很荒谬的观点(Page.593~Page.595)。&lt;/p>
&lt;ul>
&lt;li>在高级语言中，减少代码的行数就可以提升所生成的机器代码的运行速度，或是减少其资源占用——错误！&lt;/li>
&lt;li>特定运算可能比其他的快，代码规模也较小——错误！&lt;/li>
&lt;li>应当随时随地进行优化——错误！&lt;/li>
&lt;li>程序的运行速度同其正确性同等重要——错误！&lt;/li>
&lt;/ul>
&lt;p>对于这些错误的观点，书中展开做了解释。对于我来说，学习占主要成分，不是说这些错误我没有犯过，而是有些错误我还没有想到过&amp;hellip;好吧，我很受伤，桑心了。&lt;/p>
&lt;p>对于下面这句话，我觉得灰常的在理，&lt;/p>
&lt;blockquote>
&lt;p>(Page.596)程序员应当使用高质量的设计，把程序编写正确。使之模块化并易于修改，将让后期的维护工作变得很容易。&lt;/p>
&lt;/blockquote>
&lt;p>关于这句话的理解，我觉得对于软件的优化来说，设计的重要性要大于局部的代码改动。&lt;/p>
&lt;p>对于常见的影响性能的热点，书中列举了几点(Page.598~Page.599)。&lt;/p>
&lt;ul>
&lt;li>输入/输出操作&lt;/li>
&lt;li>分页&lt;/li>
&lt;li>系统调用&lt;/li>
&lt;li>解释型语言&lt;/li>
&lt;li>错误&lt;/li>
&lt;/ul>
&lt;p>关于性能的测量，作者给出了很理性的解答。例如，&lt;/p>
&lt;blockquote>
&lt;p>(Page.603)性能问题的很多方面都是违反直觉的。&amp;hellip;经验对性能优化也没有太大的帮助。&amp;hellip;在任何一种因素发生改变后，所有的经验之谈也会成为狗屁。除非对效果进行测量评估，否则你永远也无法确定某次优化所带来的影响。&lt;/p>
&lt;/blockquote>
&lt;p>对于这部分作者给出了自己的一个教训，&lt;/p>
&lt;blockquote>
&lt;p>(Page.604)我得到了一个教训，如果没有测量性能变化，那么你想当然的优化结果不过是代码变得更为晦涩难懂了。&lt;/p>
&lt;/blockquote>
&lt;p>说的很明白，对没有确实测量结果的优化，都是毫无道理的。不但如此，还让降低了代码的可读性。&lt;/p>
&lt;h2 id="第二十六章代码调整技术">第二十六章——代码调整技术&lt;/h2>
&lt;p>本章主要从代码上对优化做了讲解。首先对于逻辑判断语句提出了一些建议。&lt;/p>
&lt;ul>
&lt;li>(Page.610)在知道答案后停止判断。例如，在 &lt;!-- raw HTML omitted -->for&lt;!-- raw HTML omitted --> 循环中一旦得到结果就跳出循环，减少循环次数。&lt;/li>
&lt;li>(Page.612)按照出现频率来调整判断顺序。例如，在 &lt;!-- raw HTML omitted -->if-else&lt;!-- raw HTML omitted --> 语句和 &lt;!-- raw HTML omitted -->switch-case&lt;!-- raw HTML omitted --> 语句中，把预计频繁出现的判断尽量排到前面。&lt;/li>
&lt;/ul>
&lt;p>对于循环，也给出了一些建议。&lt;/p>
&lt;ul>
&lt;li>(Page.616)将判断外提。如果在循环运行时某个判断结果不会改变，你就可以把这个判断提到循环的外面，从而避免在循环中进行判断。&lt;/li>
&lt;li>(Page.617)合并。合并(jamming)，或融合(fusion)，就是把两个对相同一组元素进行操作的循环合并在一起。此举所带来的好处就是把两个循环的总开销减少至单个循环的开销。&lt;/li>
&lt;li>(Page.620)尽可能的减少在循环内部做的工作。&lt;/li>
&lt;li>(Page.621) 哨兵值。当循环的判断条件是一个符合判断的时候，你可以通过简化判断来节省代码运行时间。如果该循环是一个查找循环，简化方法之一就是使用一个哨兵值(sentinel value)，你可以把它放到循环范围的末尾，从而保证循环一定能够中止。&lt;/li>
&lt;li>(Page.623)把最忙的循环放到最内层。&lt;/li>
&lt;li>(Page.623)削减强度。削减强度意味着用多次轻量级运算(例如加法)来代替一次代价高昂的运算(例如乘法)。&lt;/li>
&lt;/ul>
&lt;p>在数据使用上，同样给出了一些优化的建议。&lt;/p>
&lt;ul>
&lt;li>(Page.625)使用整型数而不是浮点数。整型数的加法和乘法要比浮点数的相应运算快很多。&lt;/li>
&lt;li>(Page.625)数组维度尽可能少。&lt;/li>
&lt;li>(Page.626)尽可能减少数组引用。&lt;/li>
&lt;li>(Page.627)使用辅助索引的意思就是天假相关数据，使得对某种数据类型的访问更为高效。书中给出了两种索引方式，一种是字符串长度索引。另一种是独立的平行的索引结构。&lt;/li>
&lt;li>(Page.628)使用缓存机制。缓存机制就是把某些值存起来，使得最常用的值会比不太常用的值更容易被获取。&lt;/li>
&lt;/ul>
&lt;p>对于表达式方面，也给出了同样的一些建议，不过在这里就不列举了，因为都是用一些比较长的例子，或者是条目一一列举出来的，所以我觉得这里再列举出来感觉也没啥意思。&lt;/p>
&lt;p>最后，在子程序方面，也给出了一些优化的建议。&lt;/p>
&lt;ul>
&lt;li>(Page.639)将子程序重写为内联&lt;/li>
&lt;li>(Page.640)用低级语言重写代码&lt;/li>
&lt;/ul>
&lt;p>好啦，基本上整个这部分讲的就是这些。感觉这部分内容很杂，当然主题还是代码优化，只不过涉及到的面比较广，所以给人的感觉就比较杂。不过还好，一路看下来，并没有感到特别的云里雾里的。中心思想还是比较清晰的，脉络也比较清晰。&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（四）</title><link>https://ohcoder.com/post/2013/03/31/reading-code-complete4/</link><pubDate>Sun, 31 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/31/reading-code-complete4/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/31/reading-code-complete4/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（四）" />&lt;p>本周读了第四部分——&lt;strong>语句&lt;/strong>。&lt;/p>
&lt;p>这一部分包括的章节比较多，首先分别用 三 个章节讲述了三种常见的语句结构，随后用一章的内容谈论了一下不常见的控制结构。在使用控制结构方面，为了降低复杂度，本部分专门用一章讲述了一种方法，最后用一章内容描述了一下常见的控制问题，本部分总共包括 六 章内容。&lt;/p>
&lt;h2 id="第十四章组织直线型代码">第十四章——组织直线型代码&lt;/h2>
&lt;p>本章篇幅比较短，主要讲述了一些如何让用户从外部调用对象方法的时候能够清楚的遵循一定的顺序。换句话说，就是让别人调用你的方法的时候能够简单明了的知道这些方法的调用顺序。书中给出了一些指导原则。&lt;/p>
&lt;blockquote>
&lt;p>(Page.348)设法组织代码，使依赖关系变得非常明显&lt;/p>
&lt;/blockquote>
&lt;p>我自己的理解是，在封装类的时候，从内部尽量使方法之间的依赖降到最低。在方法功能的实现上尽可能的做到功能单一，我觉得可以比较好的解决这个问题。应该尽可能的满足 &lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted --> 原则吧。&lt;/p>
&lt;blockquote>
&lt;p>(Page.348)使子程序名能凸显依赖关系&lt;/p>
&lt;/blockquote>
&lt;p>这条原则的意思很明显，就是对所定义的方法要取个清晰的名字。&lt;/p>
&lt;blockquote>
&lt;p>(Page.349)利用子程序参数明确显示依赖关系&lt;/p>
&lt;/blockquote>
&lt;p>这个原则也不用解释过多，书中提到了一种情况，就是把几个方法的参数定义成同一个类型，以此暗示这些方法在调用参数的时候需要留心它们之间的调用关系。我自己倒是觉得，或许还可以有一种情况，那就是规定调用的 A 方法能够产生调用 B 方法所需要的参数类型，这样 A、B 方法的调用也可以从外部有一个依赖关系。&lt;/p>
&lt;blockquote>
&lt;p>(Page.350)用注释对不清晰的依赖关系进行说明&lt;/p>
&lt;/blockquote>
&lt;p>这种方法我认为属于下策，我觉得，任何通过注释进行说明的方式都是下策，我觉得好的代码应该尽量不依赖于注释，也许我的想法有些偏激，因为我觉得代码本身就是给人读的，如果通过代码仍让人琢磨不清，可能这段代码的设计偏离了 &lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted --> 原则。当然，注释能够更好的辅助我们快速了解代码，我的意思并不是说写了注释的代码就是烂代码，不要走极端。&lt;/p>
&lt;blockquote>
&lt;p>(Page.350)用断言或者错误处理代码来检查依赖关系&lt;/p>
&lt;/blockquote>
&lt;p>对于重要的代码，尽量在方法内部加上断言。其实，可以看出来，这属于防御式设计了，为了避免系统的崩溃，所采取的必要措施。&lt;/p>
&lt;p>本章后面简单说了一下，对于顺序无关的语句应该如何书写。提到了两个大的要点，一个是&lt;/p>
&lt;blockquote>
&lt;p>(Page.351)使代码易于自上而下地阅读。&lt;/p>
&lt;/blockquote>
&lt;p>另一个是&lt;/p>
&lt;blockquote>
&lt;p>(Page.352)把相关地语句组织在一起。&lt;/p>
&lt;/blockquote>
&lt;p>这两个观点都很明显，为的就是使代码阅读起来更有条理。&lt;/p>
&lt;h2 id="第十五章使用条件语句">第十五章——使用条件语句&lt;/h2>
&lt;p>本章主要是对条件语句的书写进行了讲解。条件语句分为两大类，一类是 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 语句，另一类为 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 语句。&lt;/p>
&lt;p>对于 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 语句，书中给出了一些指导原则（Page.355~Page.358）。&lt;/p>
&lt;ul>
&lt;li>首先写正常代码路径；再处理不常见情况。&lt;/li>
&lt;li>确保对于等量的分支是正确的。请不要用 &lt;!-- raw HTML omitted -->&amp;gt;&lt;!-- raw HTML omitted --> 代替 &lt;!-- raw HTML omitted -->&amp;gt;=&lt;!-- raw HTML omitted --> 或用 &lt;!-- raw HTML omitted -->&amp;laquo;/code&amp;gt; 代替 &lt;!-- raw HTML omitted -->&amp;lt;=&lt;!-- raw HTML omitted --> ，这类似于在访问数组或者计算循环下标的时候犯下 off-by-one (偏差一)错误。&lt;/li>
&lt;li>把正常情况的处理放在 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 后面而不要放在 &lt;!-- raw HTML omitted -->else&lt;!-- raw HTML omitted --> 后面&lt;/li>
&lt;li>让 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 子句后面跟随一个有意义的语句&lt;/li>
&lt;li>考虑 &lt;!-- raw HTML omitted -->else&lt;!-- raw HTML omitted --> 子句。如果你认为自己只需要一个简单的 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 语句，那么请考虑你是否真的不需要一个 &lt;!-- raw HTML omitted -->if-then-else&lt;!-- raw HTML omitted --> 语句。&lt;/li>
&lt;li>测试 &lt;!-- raw HTML omitted -->else&lt;!-- raw HTML omitted --> 子句的正确性&lt;/li>
&lt;li>检查 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 和 &lt;!-- raw HTML omitted -->else&lt;!-- raw HTML omitted --> 子句是不是弄反了&lt;/li>
&lt;/ul>
&lt;p>上面只是简单罗列了书中的一些条款，其实具体的细节，需要不断的在书写代码的时候进行调整。&lt;/p>
&lt;p>在这里，我想说两句自己偶然想到的一些认识。平时很多大牛在介绍经验的时候会经常说，“代码要多写，没有其他捷径”。针对这句话的理解，我想说两句自己的想法，之前听了这些话，听起来觉得挺有道理，但是却不知道为什么，总是用熟能生巧来简单的搪塞自己。书看到这部分的时候，我突然意识到，写代码这项运动，其实不是简单的提高打字速度，也不单单是熟练使用语言中的关键字。其实，更多的涉及到的部分是习惯和思维方式的培养问题，通过不断在代码上的调整，来调整我们的思维方式，之后通过不断的重复，让这种调整后的行为逐渐的成为我们的习惯，以此来逐渐的规范我们的代码编写方式。久而久之，即便在你无意识的情况下也可以反射性的写出高质量的代码。这个时候我想就达到了代码要多写的目的。&lt;/p>
&lt;p>恩，经过这样的简单分析，我就基本上理解了大牛们说的代码要多写的真正含义。好吧吧，也许有朋友看到这里觉得我有点死较真儿，或者说这么明显的道理都看不出来，如果屏幕前的您早就想到了，对着屏幕呵呵呵就行了，见谅！:)。坦白说，之前确实没有想太多，或者说，总感觉多写代码为的只是增加对某种语言的关键字使用的熟练程度，真的没有意识到其实最终为的是改变你的思维方式和行为习惯。&lt;/p>
&lt;p>好吧，说了两句突发奇想的感悟，下面还回到正题上来。接下来说的是 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 语句。对于 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 语句的有效排列顺序而言，书中给出了三种建议。&lt;/p>
&lt;ul>
&lt;li>按字母排序或按数字排序排列各种情况&lt;/li>
&lt;li>把正常的情况放在前面&lt;/li>
&lt;li>按执行频率排列 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 子句&lt;/li>
&lt;/ul>
&lt;p>上面提到的三种排列建议都比较好理解。接下来作者给出了几个使用 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 语句的小提示。&lt;/p>
&lt;blockquote>
&lt;p>(Page.361)简化每种情况对应的操作&lt;/p>
&lt;/blockquote>
&lt;p>其实，就是尽可能让每个 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 里的功能单一。&lt;/p>
&lt;blockquote>
&lt;p>(Page.361)不要为了使用 case 语句而刻意制造一个变量&lt;/p>
&lt;/blockquote>
&lt;p>这句话也很好理解，不要为了 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 而 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> ，凡事都有个度。&lt;/p>
&lt;blockquote>
&lt;p>(Page.363)把 default 子句只用于检查真正的默认情况&lt;/p>
&lt;/blockquote>
&lt;p>这句比较好理解，不要滥用 &lt;!-- raw HTML omitted -->default&lt;!-- raw HTML omitted -->。&lt;/p>
&lt;h2 id="第十六章控制循环">第十六章——控制循环&lt;/h2>
&lt;p>本章主要讲循环语句。对于 &lt;!-- raw HTML omitted -->for&lt;!-- raw HTML omitted --> 循环的使用，书中做了说明。&lt;/p>
&lt;blockquote>
&lt;p>(Page.372)如果你需要一个执行次数固定的循环，那么 for 循环就是一个很好的选择。&lt;/p>
&lt;/blockquote>
&lt;p>除此之外，书中对于何时用 &lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted --> 循环代替 &lt;!-- raw HTML omitted -->for&lt;!-- raw HTML omitted --> 循环也做了说明。&lt;/p>
&lt;blockquote>
&lt;p>(Page.372) for 循环的关键之处在于，你在循环头处把它写好后就可以忘掉它了，无需在循环的内部做任何事情去控制它。如果存在一个必须使执行从循环中跳出的条件，那么就应该改用 &lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted --> 循环。&lt;/p>
&lt;/blockquote>
&lt;p>其实，对于 &lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted --> 循环，说实话，我在代码中很少使用，一般情况下用 &lt;!-- raw HTML omitted -->for&lt;!-- raw HTML omitted --> 或者使用&lt;!-- raw HTML omitted -->foreach&lt;!-- raw HTML omitted -->循环就够用了。在 &lt;!-- raw HTML omitted -->Golang&lt;!-- raw HTML omitted --> 语言中也确实去掉了 &lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted --> 循环，我想这也说明了 &lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted --> 语句的使用确实可以被替代。&lt;/p>
&lt;p>对于循环控制，书中给出了一些建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.374)用 while(true) 表示无限循环&lt;/p>
&lt;/blockquote>
&lt;p>对于无限循环的使用，就用上面的建议就行了。不过，如果不涉及网络或动画，一般也用不到无限循环。&lt;/p>
&lt;blockquote>
&lt;p>(Page.374)在适当的情况下多使用 for 循环&lt;/p>
&lt;/blockquote>
&lt;p>其实从 &lt;!-- raw HTML omitted -->Golang&lt;!-- raw HTML omitted --> 语法中去掉 &lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted --> 关键字已经很说明问题了。&lt;/p>
&lt;p>对于处理循环体，书中也给出了几条建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.375)用 { 和 } 把循环中的语句括起来。任何时候都要在代码中使用括号。&lt;/p>
&lt;/blockquote>
&lt;p>这一习惯可以让别人更清晰的阅读代码。&lt;/p>
&lt;blockquote>
&lt;p>(Page.375)避免空循环&lt;/p>
&lt;/blockquote>
&lt;p>我倒是没有这种习惯，一来觉得影响美观，二来会让代码看起来不是很清晰。&lt;/p>
&lt;blockquote>
&lt;p>(Page.376)把循环内务操作要么放在循环的开始，要么放在循环的末尾。&lt;/p>
&lt;/blockquote>
&lt;p>这条建议目的觉得就是为了让书写代码更有规律可循，避免胡乱摆放代码。&lt;/p>
&lt;blockquote>
&lt;p>(Page.376)一个循环只做一件事&lt;/p>
&lt;/blockquote>
&lt;p>这条建议很直观，遵守 &lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted --> 原则。&lt;/p>
&lt;p>对于循环的退出，书中也给出了一些建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.377)不要为了终止循环而胡乱改动 for 循环的下标&lt;/p>
&lt;/blockquote>
&lt;p>这个错误我好像从来没干过。还有下一条建议从来没尝试过，从来没想过这么用，看了书中的例子才知道，原来还可以酱紫犯错误，也算是开眼了。&lt;/p>
&lt;blockquote>
&lt;p>(Page.377)避免出现依赖于循环下标最终取值的代码&lt;/p>
&lt;/blockquote>
&lt;p>以上两点除了让代码更紧凑以外，还主要是为了尽可能的不要让 bug 蔓延。书中还提到一个方法，老实说我之前没想到过，长姿势了。&lt;/p>
&lt;blockquote>
&lt;p>(Page.378)考虑使用安全计数器&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//C++示例：本应使用安全计数器的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Next&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Next&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 下面是使用了安全计数器的同一代码段：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//C++示例：使用了安全计数器的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">safetyCounter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Next&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">safetyCounter&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//安全计数器代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">safetyCounter&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">SAFETY_LIMIT&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//安全计数器代码段
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Internal Error: Safety-Counter Violation.&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nod&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Next&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关于安全计数器，有利就有弊。书中说出了其中的利弊，&lt;/p>
&lt;blockquote>
&lt;p>(Page.379)每次都在代码里使用一个安全计数器，也会增加复杂度，并且可能引发其他的错误。&amp;hellip;然而，如果把安全计数器作为整个项目的一种标准应用于关键的循环，那么含有安全计数器的代码不会比其他的代码更容易出错。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>(Page.383)把循环下标变量的作用域限制在本循环内&lt;/p>
&lt;/blockquote>
&lt;p>关于这一点，书中后面也说了，不同的 &lt;!-- raw HTML omitted -->C++&lt;!-- raw HTML omitted --> 编译器会对此语法做出不同的反映。所以如果想用 &lt;!-- raw HTML omitted -->C++&lt;!-- raw HTML omitted --> 做跨平台开发，个人建议还是把循环变量放到循环体外进行声明。例如，&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//C++示例
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">MAX&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关于循环代码的长度，书中给出了一些建议 (Page.385)。&lt;/p>
&lt;ul>
&lt;li>循环要尽可能的短，以便能够一目了然。如果你开始接受编写简单代码这一原则，那就很少会写出超过 15 或者 20 行的循环。&lt;/li>
&lt;li>把嵌套限制在 3 层以内&lt;/li>
&lt;li>把长循环的内容移到子程序里&lt;/li>
&lt;li>要让长循环格外清晰&lt;/li>
&lt;/ul>
&lt;p>都是一些书写规则，很醒目，就不多做解释了。&lt;/p>
&lt;h2 id="第十七章不常见的控制结构">第十七章——不常见的控制结构&lt;/h2>
&lt;p>本章的主要内容有两方面，一方面是递归。另一方面是容易引起纠纷的 &lt;!-- raw HTML omitted -->goto&lt;!-- raw HTML omitted --> 语句。&lt;/p>
&lt;p>关于递归的使用，书中有一段话做了概要性的说明。&lt;/p>
&lt;blockquote>
&lt;p>(Page.394)对于大多数问题，它所带来的解将会是及其复杂的——在那些情况下，使用简单的迭代通常会比较容易理解。因此要有选择地使用递归。&lt;/p>
&lt;/blockquote>
&lt;p>使用递归技巧方面，有几点还是需要注意的。&lt;/p>
&lt;blockquote>
&lt;p>(Page.396)把递归限制在一个子程序内。循环递归( A 调用 B，B 调用 C，C 调用 A )非常危险，因为它很难检查。&lt;/p>
&lt;/blockquote>
&lt;p>对于这一点，我想我还真没遇到过，不过也可能是我遇到了没查出来&amp;hellip;&lt;/p>
&lt;blockquote>
&lt;p>(Page.397)留心栈空间&lt;/p>
&lt;/blockquote>
&lt;p>对于这一点书中做了解释，&lt;/p>
&lt;blockquote>
&lt;p>(Page.397)应注意观察递归函数中局部变量的分配情况，特别要刘毅那些内存消耗大的对象。换句话说，要用&lt;!-- raw HTML omitted -->new&lt;!-- raw HTML omitted -->在堆(heap)上创建对象，而不要让编译器在栈上自动创建对象。&lt;/p>
&lt;/blockquote>
&lt;p>下面要说到 &lt;!-- raw HTML omitted -->goto&lt;!-- raw HTML omitted --> 语句，对于 &lt;!-- raw HTML omitted -->goto&lt;!-- raw HTML omitted --> 我不想多说，免得引火烧身。我发表两点看法，第一点是在合适的地方使用 &lt;!-- raw HTML omitted -->goto&lt;!-- raw HTML omitted -->，所谓合适的地方是，明显能降低复杂度而又不让代码的可读性变的混乱的情况下。第二点是在 &lt;!-- raw HTML omitted -->Golang&lt;!-- raw HTML omitted -->中依然保留了&lt;!-- raw HTML omitted -->goto &lt;!-- raw HTML omitted --> 的位置。&lt;/p>
&lt;h2 id="第十八章表驱动法">第十八章——表驱动法&lt;/h2>
&lt;p>本章的第一句话概括的很好，&lt;/p>
&lt;blockquote>
&lt;p>(Page.411)表驱动法是一种编程模式(scheme)——从表里面查找信息而不使用逻辑语句(if和case)。&lt;/p>
&lt;/blockquote>
&lt;p>其实，看完整个章节，我的感受只有一条，就是用空间换时间，降低控制的复杂度。&lt;/p>
&lt;p>关于从表里面查找信息的方法。书中描述了三种方法：&lt;/p>
&lt;ul>
&lt;li>直接访问(Direct access)&lt;/li>
&lt;li>索引访问(Indexed access)&lt;/li>
&lt;li>阶梯访问(Stair-step access)&lt;/li>
&lt;/ul>
&lt;p>关于这三种方法的使用方式，我觉得结合书中的例子看更容易理解。当然了，对于访问表数据，核心问题无非就是查询。具体的方法就不说了，因为书中的方法都是针对了具体的例子而言。只是干巴巴的说，看起来会有很多逻辑漏洞。&lt;/p>
&lt;h2 id="第十九章一般控制问题">第十九章——一般控制问题&lt;/h2>
&lt;p>本章主要是对前面几章所说的控制方式中常见的问题进行了描述。&lt;/p>
&lt;p>首先说的是布尔表达式。&lt;/p>
&lt;blockquote>
&lt;p>(Page.431)除了最简单的、要求语句按顺序执行的控制结构外，所有的控制结构都依赖于布尔表达式的求值(evaluation)。&lt;/p>
&lt;/blockquote>
&lt;p>随后，书中主要在讲使用布尔表达式时候的注意事项。这里就不多说了，都是一些常见的问题，点很多。但主导思想还是 &lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted --> 原则。&lt;/p>
&lt;p>接下来对复合语句或语句块做了简单的描述，并建议尽量用括号把条件表达清楚等等。&lt;/p>
&lt;p>对于如何减少深层嵌套，书中做了技术总结。&lt;/p>
&lt;ul>
&lt;li>重复判断一部分条件&lt;/li>
&lt;li>转换成 if-then-else&lt;/li>
&lt;li>转换成 else 语句&lt;/li>
&lt;li>把深层嵌套的代码提取诚单独的子程序&lt;/li>
&lt;li>使用对象和多态派分( polymorphic dispatch )&lt;/li>
&lt;li>用状态变量重写代码&lt;/li>
&lt;li>用防卫子句来退出子程序，从而使代码的主要路径更为清晰&lt;/li>
&lt;li>使用异常&lt;/li>
&lt;li>完全重新设计深层嵌套的代码&lt;/li>
&lt;/ul>
&lt;p>关于结构化编程，讲到了结构化编程的核心思想，&lt;/p>
&lt;blockquote>
&lt;p>(Page.454)&amp;hellip;那就是一个应用程序应该只采用一些单入单出的控制结构(也称为单一入口、单一出口的控制结构)。&lt;/p>
&lt;/blockquote>
&lt;p>结构化编程由三个部分组成(Page.454~Page.456)：&lt;/p>
&lt;ul>
&lt;li>顺序(Sequence)&lt;/li>
&lt;li>选择(Selection)&lt;/li>
&lt;li>迭代(Iteration)&lt;/li>
&lt;/ul>
&lt;p>结构化编程的中心论点，书中也做了说明。&lt;/p>
&lt;blockquote>
&lt;p>(Page.456)&amp;hellip;任何一种控制流都可以由顺序、选择和迭代这三种结构生成。&lt;/p>
&lt;/blockquote>
&lt;p>关于如何度量复杂度，书中给出了一种计算方法。&lt;/p>
&lt;ol>
&lt;li>从 1 开始，一直往下通过程序&lt;/li>
&lt;li>一旦遇到以下关键字，或者其同类的词，就加 1:
&lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted -->、&lt;!-- raw HTML omitted -->while&lt;!-- raw HTML omitted -->、&lt;!-- raw HTML omitted -->repeat&lt;!-- raw HTML omitted -->、&lt;!-- raw HTML omitted -->for&lt;!-- raw HTML omitted -->、&lt;!-- raw HTML omitted -->and&lt;!-- raw HTML omitted -->、&lt;!-- raw HTML omitted -->or&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>给 &lt;!-- raw HTML omitted -->case&lt;!-- raw HTML omitted --> 语句中的每一种情况都加1&lt;/li>
&lt;/ol>
&lt;p>下面举书中的例子(Page.458)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Success&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">done&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="n">or&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">(&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">done&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">numLines&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">maxLines&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="p">)&lt;/span> &lt;span class="n">then&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这段代码中，从 1 算起，遇到 &lt;!-- raw HTML omitted -->if&lt;!-- raw HTML omitted --> 得 2，&lt;!-- raw HTML omitted -->and &lt;!-- raw HTML omitted --> 得 3，&lt;!-- raw HTML omitted -->or &lt;!-- raw HTML omitted --> 得 4，&lt;!-- raw HTML omitted -->and&lt;!-- raw HTML omitted --> 得 5。加起来这段代码里总共包含了 5 个决策点。&lt;/p>
&lt;p>关于决策结果的评判，书中也给出了评判标准(Page.458)：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数值范围&lt;/th>
&lt;th style="text-align:left">结果描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 —— 5&lt;/td>
&lt;td style="text-align:left">子程序可能还不错&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6 —— 10&lt;/td>
&lt;td style="text-align:left">得想办法简化子程序了&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10+&lt;/td>
&lt;td style="text-align:left">把子程序的某一部分拆成另一个子程序并调用它&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>整体上来说，这部分的主要内容就是控制结构，这几章都紧扣主题，而且我发现所有实施的办法都是为了控制复杂度，到目前为止，和之前的猜测还一直比较吻合。总体策略上，我发现主线就是遵守&lt;!-- raw HTML omitted -->KISS&lt;!-- raw HTML omitted -->原则。&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（三）</title><link>https://ohcoder.com/post/2013/03/24/reading-code-complete3/</link><pubDate>Sun, 24 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/24/reading-code-complete3/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/24/reading-code-complete3/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（三）" />&lt;p>继续上一周的阅读，本周读了第三部分－变量。&lt;/p>
&lt;p>整个第三部分，包括第 10 章到第 13 章，一共有四章都是围绕变量展开。可见变量在程序设计当中有多重要。&lt;/p>
&lt;h2 id="第十章使用变量的一般事项">第十章－使用变量的一般事项&lt;/h2>
&lt;p>从本章标题中也可以看出，本章主要就是在讲变量的使用。&lt;/p>
&lt;p>本章一开始，作者就提到关于隐式变量声明的观点。例如：&lt;/p>
&lt;blockquote>
&lt;p>(Page.240)隐式变量声明对于任何一种语言来说都是最具危险性的特性之一&lt;/p>
&lt;/blockquote>
&lt;p>作者给出的解决办法是：&lt;/p>
&lt;ul>
&lt;li>关闭隐式声明&lt;/li>
&lt;li>声明全部的变量&lt;/li>
&lt;li>遵循某种命名规则&lt;/li>
&lt;li>检查变量名&lt;/li>
&lt;/ul>
&lt;p>其实，关于这一点，现代解释型脚本语言貌似很多都支持隐式声明，例如&lt;!-- raw HTML omitted -->Javascript&lt;!-- raw HTML omitted -->。但是作者说的并不无道理，我用脚本语言用的还不是很多，没有太多经验来总结其中的利弊，暂且采用作者说的方法。&lt;/p>
&lt;p>在作用域一节中，作者提出了两个概念，一个是&lt;/p>
&lt;blockquote>
&lt;p>(Page.245)跨度*”，另一个是“*(Page.246)存活时间(live time)。&lt;/p>
&lt;/blockquote>
&lt;p>所谓跨度，作者引出了其定义&lt;/p>
&lt;blockquote>
&lt;p>(Page.245)衡量又一个变量的不同引用点的靠近程度的一种方法是计算该变量的“跨度(span)。&lt;/p>
&lt;/blockquote>
&lt;p>所谓存活时间，&lt;/p>
&lt;blockquote>
&lt;p>(Page.246)即一个变量存在期间所跨越的语句总数。&lt;/p>
&lt;/blockquote>
&lt;p>也由此可见，对于变量来说保持跨度值和存活时间尽可能的短是主要目标。&lt;/p>
&lt;p>对于减小变量作用域，作者给出了一些建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.249)在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量&lt;/p>
&lt;/blockquote>
&lt;p>对于这一条建议，作者的目的是能够在循环里正确的使用外部初始化的变量。比如你把一个变量的声明和使用这个变量的循环之间隔离的很远的话，当需要修改循环的时候比较不容易看到循环中使用的这个变量。&lt;/p>
&lt;blockquote>
&lt;p>(Page.249)直到变量即将被使用时再为其赋值&lt;/p>
&lt;/blockquote>
&lt;p>这一条建议，我觉得很容易理解，主要就是为了让代码的初始化更醒目。&lt;/p>
&lt;blockquote>
&lt;p>(Page.250)当对变量的作用域犹豫不决的时候，你应该倾向于选择该变量所能具有的最小作用域&lt;/p>
&lt;/blockquote>
&lt;p>这条建议，其实目的也是为了尽可能的降低变量的生存时间。&lt;/p>
&lt;blockquote>
&lt;p>(Page.252)采用越晚的绑定时间会越有利&lt;/p>
&lt;/blockquote>
&lt;p>关于绑定时间书中给出了三种情况：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Java示例：在编写代码时绑定其值的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">titleBar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0xFF&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//0xFF is hex value for color blue
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Java示例：在编译时绑定其值的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">COLOR_BLUE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0xFF&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">TITLE_BAR_COLOR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">COLOR_BLUE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">titleBar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TITLE_BAR_COLOR&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Java示例：在运行时绑定其值的变量 titleBar.color =
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ReadTitleBarColor&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关于这一点就不多做解释了。示例已经说明问题了。&lt;/p>
&lt;h2 id="第十一章变量名的力量">第十一章－变量名的力量&lt;/h2>
&lt;p>全章讲述的是变量命名，对于大的项目而言，好的变量名不但使程序更容易读懂和编写，而且还利于以后的 bug 调试。&lt;/p>
&lt;p>对于如何命名，书中提到了一点建议，我觉得之前可能做的也不太好。&lt;/p>
&lt;blockquote>
&lt;p>(Page.261)一个好记的名字反映的通常都是问题，而不是解决方案。一个好名字通常表达的是“什么”(what)，而不是“如何”(how)。&lt;/p>
&lt;/blockquote>
&lt;p>作者说，&lt;/p>
&lt;blockquote>
&lt;p>(Page.261)一般而言，如果一个名字反映了计算的某些方面而不是问题本身，那么它反映的就是“how”而非“what”了。&lt;/p>
&lt;/blockquote>
&lt;p>关于名字的长度，文中提到&lt;/p>
&lt;blockquote>
&lt;p>(Page.262)当变量名的平均长度在 10 到 16 个字符的时候，调试程序所需花费的力气是最小的(1990)。&lt;/p>
&lt;/blockquote>
&lt;p>其实，我觉得， &lt;!-- raw HTML omitted -->Objective
C&lt;!-- raw HTML omitted --> 这门语言天生就挺符合这个要求的，不用你刻意去注意，哈哈。&lt;/p>
&lt;p>对于变量中使用计算限定词，文中也给出了很好的建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.263)如果你要用类似与 Total、Sum、Average、Max、Min、Record、String、Pointer 这样的限定词来修改某个名字，那么请记住把限定词加到限定词名字的最后。&lt;/p>
&lt;/blockquote>
&lt;p>对于文中所说何时采用命名规则，我觉得，平时就养成这个习惯吧，不论怎样，这个习惯都不是一个坏习惯。&lt;/p>
&lt;p>与语言无关的命名规则的指导原则，书中也给出了几种方案(Page.272)。&lt;/p>
&lt;p>&lt;strong>方案 1&lt;/strong>: 通过大写字母开头区分类型和变量，例如： &lt;!-- raw HTML omitted -->Widget 与 widget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LongerWidget 与 longerWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案 2&lt;/strong>: 通过全部大写区分类型和变量，例如： &lt;!-- raw HTML omitted -->WIDGET 与 widget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LONGERWIDGET 与 longerWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案 3&lt;/strong>: 通过给类型“t_”前缀区分类型和变量，例如： &lt;!-- raw HTML omitted -->t_Widget 与 widget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->t_LongerWidget 与 LongerWidger;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案 4&lt;/strong>: 通过给变量“a”前缀区分类型和变量，例如： &lt;!-- raw HTML omitted -->Widget 与 aWidget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LongerWidget 与 aLongWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案 5&lt;/strong>: 通过对变量采用更明确的名字区分类型和变量，例如： &lt;!-- raw HTML omitted -->Widget 与  employeeWidget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LongerWidget   与 fullEmployeeWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>书中对每一种方案的优缺点做了描述(Page.272~Page.273)：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一种方案是在大小写敏感语言如 C++ 和 Java 里常用的规则，但是有些程序员对仅依靠大小写区分名字感到不大舒服。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二种方案使类型名和变量名之间的差异更加鲜明。然而，由于历史原因，在 C++ 和 Java 里面全部字母大写只用于表示常量，同时这种方案也会与第一种方案一样面临混合语言环境的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三种方案可用于所有语言，但是很多程序员从审美的角度出发并不喜欢增加前缀。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第四种方案有时会用作第三种方案的备选项，但是它存在的问题是需要改变类的每个实例的名字，而不是仅仅修改类名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第五种方案要求基于每个变量的实际情况作出更多的考虑。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>本章后面说了下应该避免的命名指导原则，原则有很多，我觉得都是非常常见的命名错误，在这里就不罗列了。&lt;/p>
&lt;h2 id="第十二章基本数据类型">第十二章－基本数据类型&lt;/h2>
&lt;p>本章对每一种基本数据类型的使用进行了详细讲解。首先从全局上给出了一些建议(Page.292~Page.293)。&lt;/p>
&lt;ul>
&lt;li>避免使用“神秘数值(magic number)” 。如果需要，可以使用硬编码的 0 和 1&lt;/li>
&lt;li>预防除零(devide-by-zero)错误，使类型转换变得明显。&lt;/li>
&lt;li>避免混合类型的比较，注意编译器的警告。&lt;/li>
&lt;/ul>
&lt;p>本章后面的基本类型差不多都是围绕着上面这几点根据具体的类型特点展开来讲的。其中印象比较深刻的是关于浮点数的一条建议：&lt;/p>
&lt;blockquote>
&lt;p>(Page.295)避免等量判断&lt;/p>
&lt;/blockquote>
&lt;p>很早之前掉进过这个坑。记得当时用了两个浮点数值进行等值判断，结果相等的概率非常的低，后来打印了一下数值，才发现掉到坑去里了，后来就长记性了，呵呵。&lt;/p>
&lt;p>对于&lt;!-- raw HTML omitted -->C&lt;!-- raw HTML omitted -->语言的字符串的使用，有几个建议印象比较深刻。&lt;/p>
&lt;blockquote>
&lt;p>(Page.299)把 C-Style 字符串的长度声明为 CONSTANT + 1&lt;/p>
&lt;/blockquote>
&lt;p>这一条建议可以避免循环数组时越界，当然这种写法在很多算法书中也很常见。&lt;/p>
&lt;blockquote>
&lt;p>(Page.300)用 null 初始化字符串以避免无结束符的字符串&lt;/p>
&lt;/blockquote>
&lt;p>这条在平时初始化的时候也很受用。下面这条是关于分配内存并初始化的建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.300)其次，在你动态分配字符串的时候，使用 calloc()而不是 malloc()来把它初始化为 0。calloc()会负责分配内存，并把它初始化为 0。malloc()只分配内存，并不执行初始化。……&lt;/p>
&lt;/blockquote>
&lt;p>对于定义枚举类型，文中给出了两条之前没有注意的点。&lt;/p>
&lt;blockquote>
&lt;p>(Page.305)定义出枚举的第一项和最后一项，以便用于循环边界&lt;/p>
&lt;/blockquote>
&lt;p>这一点以前还真没注意过，以后要注意了。还有下一点，我觉得也是蛮有道理的，虽然表面上感觉有点小聪明的意思，呵呵。&lt;/p>
&lt;blockquote>
&lt;p>(Page.305)把枚举类型的第一个元素留作非法值&lt;/p>
&lt;/blockquote>
&lt;p>本章后面谈论了一下使用&lt;!-- raw HTML omitted -->typedef&lt;!-- raw HTML omitted -->进行自定义类型，感觉没有太多要说的。&lt;/p>
&lt;h2 id="第十三章不常见的数据类型">第十三章－不常见的数据类型&lt;/h2>
&lt;p>本章主要是在讲非基本数据类型。主要包括结构、指针、全局数据。其实，关于这一章里，结构没有什么好说的，很多常见的语法书中该说的基本都说到了，包括结构化数据的优点等。关于 &lt;!-- raw HTML omitted -->C/C++&lt;!-- raw HTML omitted --> 语言指针部分，其实很多基本概念在一些权威的书中基本也都提到过，没什么感觉。最后的讲了全局数据，当然主要就是全局数据的弊端占用了很多篇幅，以及如何避免使用全局数据等。避免的方式，感觉还是通过重构，尽量使程序模块化，降低变量的生存时间，也避免在内存堆中分配空间，达到节省内存的目的等等。&lt;/p>
&lt;p>总体来说，这部分的内容不少，但是有些知识已经在一些权威的语法书中能够找到，读起来相对来说没有前两部分难懂，可能有些问题是平时写程序的时候经常会碰到的原因吧，见的多了，神经就有点麻木了，呵呵。&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（二）</title><link>https://ohcoder.com/post/2013/03/17/reading-code-complete2/</link><pubDate>Sun, 17 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/17/reading-code-complete2/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/17/reading-code-complete2/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（二）" />&lt;p>本周读了第二部分－&lt;strong>创建高质量的代码&lt;/strong>。&lt;/p>
&lt;p>说实话，真的好后悔没有早点读这本书，觉得自己以前写的代码就是一坨&lt;!-- raw HTML omitted -->Shǐ&lt;!-- raw HTML omitted -->。看书的过程中，一边看就觉得后脊梁发凉，一阵阵凉风从后背吹过……&lt;/p>
&lt;p>本部分分为五章，基本上还是从顶层设计角度探讨了如何更好的编写代码。分别从软件的设计、类的封装、子程序的设计以及防御式编程和使用伪代码进行开发方法方面进行了探讨。感觉书中需要学习点太多了，好多方面看完之后都有感触。想了想，如果都列出来感觉可以写一本小册子了，所以在这里还是随意挑几个标题大(Y( ^ _ ^ )Y)的记录一下吧，太细的点就不列了。不过虽然有的点不是大标题，但并不代表这些点不重要，有时间的话，我想我还会经常回过头来当手册来翻一翻的。&lt;/p>
&lt;h2 id="第五章软件创建中的设计">第五章－软件创建中的设计&lt;/h2>
&lt;p>本章的一个核心思想是如何更合理的控制复杂度。&lt;/p>
&lt;blockquote>
&lt;p>(Page.77)软件的首要技术使命：管理复杂度&lt;/p>
&lt;/blockquote>
&lt;p>书中首先阐述了管理复杂度的重要性，并指出产生高代价、低效率的设计源于下面三种根源：&lt;/p>
&lt;ul>
&lt;li>用复杂的方法解决简单的问题；&lt;/li>
&lt;li>用简单但错误的方法解决复杂的问题；&lt;/li>
&lt;li>用不恰当的复杂方法解决复杂的问题。&lt;/li>
&lt;/ul>
&lt;p>关于这一点，书中描述了两种方法来解决这个问题：&lt;/p>
&lt;ul>
&lt;li>把任何人在同一时间需要处理的本质（essential）复杂度的量减到最少；&lt;/li>
&lt;li>不要让偶然性（accidental）的复杂度无谓地快速增长。&lt;/li>
&lt;/ul>
&lt;p>关于如何控制复杂度这个问题，看了下整本书的目录，不管是从顶层对软件的设计，还是深入到底层的代码编写，貌似都是为了更好的控制复杂度，不过我整本书还没看完，只是感觉而已。&lt;/p>
&lt;p>回过头来想了想，在我曾经做过的项目中。虽然有的项目外表上看起来算是完成了，不过我感觉，在做项目的过程中，多少都冒犯了上面指出的三种根源。只不过上面总结的很抽象，具体实施起来会涉及到很多方面。呵呵，这当然是一个复杂的问题。&lt;/p>
&lt;p>随后，书中说了理想的设计特征包括哪些范畴：&lt;/p>
&lt;ul>
&lt;li>最小的复杂度（Minimal complexity）&lt;/li>
&lt;li>易于维护（Ease of maintenance）&lt;/li>
&lt;li>松散耦合（loose coupling）&lt;/li>
&lt;li>可扩展性（extensibility）&lt;/li>
&lt;li>高扇入（high fan-in）&lt;/li>
&lt;li>低扇出（low fan-out）&lt;/li>
&lt;li>可移植性（portability）&lt;/li>
&lt;li>精简性（leanness）&lt;/li>
&lt;li>层次性（stratification）&lt;/li>
&lt;li>标准技术（Standard techniques）&lt;/li>
&lt;/ul>
&lt;p>其中，关于最小的复杂度部分，我觉得书中有一句话说的很形象。&lt;/p>
&lt;blockquote>
&lt;p>(Page.80)如果你的设计方案不能让你在专注于程序的一部分时安心地忽视其他部分地话，这一设计就没有什么作用了。&lt;/p>
&lt;/blockquote>
&lt;p>精简性方面，书中指出&lt;/p>
&lt;blockquote>
&lt;p>(Page.81)精简性意味着设计出的系统没有多余的部分(Wirth 1995,McConnell 1997)。&lt;/p>
&lt;/blockquote>
&lt;p>除此之外，对于高扇入和低扇出，其实之前貌似重视不够，尤其是低扇出，以后要注意这一点了，至于其他方面，平时看的也比较多，应该还算是不陌生吧。&lt;/p>
&lt;p>书中后面讲到隐藏秘密(信息隐藏)。这其中主要分为了两大类：&lt;/p>
&lt;ul>
&lt;li>隐藏复杂度&lt;/li>
&lt;li>隐藏变化源&lt;/li>
&lt;/ul>
&lt;p>老实说，看过这部分之后，回想了下之前写过的代码，我觉得做的很不够，和书中所描述的点相差甚远，真是觉得汗颜。也感觉到设计好的接口是如此之难，能够设计好的接口真不是简单吹吹牛就能做好的，需要多方面的综合考虑才有可能更合理的对接口进行设计。&lt;/p>
&lt;p>对于设计模式的用处，书中列出了设计模式的几个益处，我想根据这几个点，多少也可以指导我们平时如何更合理的使用设计模式吧。&lt;/p>
&lt;ul>
&lt;li>设计模式通过提供现成的抽象来减少复杂度&lt;/li>
&lt;li>设计模式通过把常见解决方案的细节予以制度化来减少出错&lt;/li>
&lt;li>设计模式通过提供多种设计方案而带来启发性的价值&lt;/li>
&lt;li>设计模式通过把设计对话提升到一个更高的层次上来简化交流&lt;/li>
&lt;/ul>
&lt;p>对于这几个益处，针对设计模式，我觉得，设计模式仅仅是一种框架，可以用来降低复杂度，减少错误，可以依赖这些模式做一些变化来适应需要解决的问题，最后是利于码农之间更好的交流。所以从这几个方面看，学习设计模式一定不要死记硬背，更好的掌握使用这些模式的场景更重要，所谓手中无剑，心中也无剑，此为高手。&lt;/p>
&lt;p>关于这章的其他部分提了一些具体实践的方法，说了一些方法论，和具体实践结合很紧密。关于保持松散耦合这方面，书中也提了哪些方面可能会产生耦合，以及耦合常见的形式。&lt;/p>
&lt;p>本章后面讨论了一下自上而下和自下而上的设计方法。作者的结论是，两种方式各有利弊，并非排斥关系。自上而下从一般性的问题出发，把该问题分解成可控的部分。而自下而上从可控的部分出发，去构造一个适用的方案。这两种方法都有各自的强项和弱项。设计过程中，你会受益于二者的相互协作。&lt;/p>
&lt;h2 id="第六章可以工作的类">第六章－可以工作的类&lt;/h2>
&lt;p>本章讨论了设计类的接口。书中给出了几个 C++的代码例子，以说明良好的接口应该如何设计。书中有几个点很有启发性，其中有一句是&lt;/p>
&lt;blockquote>
&lt;p>(Page.138)关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计&lt;/p>
&lt;/blockquote>
&lt;p>对于类进行良好的封装，作者给出了几条建议：&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)尽可能地限制类和成员的可访问性&lt;/p>
&lt;/blockquote>
&lt;p>关于这条建议，书中引用了 Meyers 的一句话，&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)应该采用最严格且可行的访问级别(Meyers 1998,Block 2001)。&lt;/p>
&lt;/blockquote>
&lt;p>意思很明显，就是说，如果你不确定，那么多隐藏通常比少隐藏要好。&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)不要公开暴露成员数据&lt;/p>
&lt;/blockquote>
&lt;p>这一点很明显，暴露成员数据会破坏封装性。这一点对于 C++ 来说更应该注意，因为对于 &lt;!-- raw HTML omitted -->C#&lt;!-- raw HTML omitted --> 和 &lt;!-- raw HTML omitted -->Java&lt;!-- raw HTML omitted --> 来说都有对应的访问器来隐藏成员数据，而 &lt;!-- raw HTML omitted -->Objective C&lt;!-- raw HTML omitted -->，则会对每个向外暴露的成员同样也会生成对应 &lt;!-- raw HTML omitted -->Set&lt;!-- raw HTML omitted --> 和 &lt;!-- raw HTML omitted -->Get&lt;!-- raw HTML omitted --> 方法。呃，对于语言的讨论就此打住吧&amp;hellip;&amp;hellip;&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)避免把私用的实现细节放入类的接口中&lt;/p>
&lt;/blockquote>
&lt;p>对于这一点，原来一起工作的同事有讨论过相关的问题。对于这一点《&lt;a class="link" href="http://book.douban.com/subject/5387403/" target="_blank" rel="noopener"
>Effective C++&lt;/a>》书中也有详细讨论，具体的可以翻一翻这本书。另外，这一点感觉也是&lt;!-- raw HTML omitted -->C++&lt;!-- raw HTML omitted -->的一个坑，其他语言应该可以比较容易的规避这个问题。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)不要对类的使用者做出任何假设&lt;/p>
&lt;/blockquote>
&lt;p>关于这一点，我想没什么好解释的，很显然的事情。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)避免使用友元类(friend class)&lt;/p>
&lt;/blockquote>
&lt;p>书中说到，&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)一般情况下友元类会破坏封装，因为它让你在同一时刻需要考虑更多的代码量，从而增加了复杂度。&lt;/p>
&lt;p>(Page.141)不要因为一个子程序里仅使用公用子程序，就把它归入公开接口&lt;/p>
&lt;/blockquote>
&lt;p>这一点考虑的问题是，如果把某个子程序暴露给外界后，接口所展示的抽象是否还能保持一致。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)让阅读代码比编写代码更方便&lt;/p>
&lt;/blockquote>
&lt;p>关于这一点，书中强调还是代码的可读性。时刻要防止接口设计的一致性问题，一旦出现接口定义不规范的问题后，不但开始影响代码的可读性，而且还有可能会出现《&lt;a class="link" href="http://book.douban.com/subject/1152111/" target="_blank" rel="noopener"
>程序员修炼之道&lt;/a>》中所说的破窗户问题。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)要格外警惕从语意破坏封装性&lt;/p>
&lt;/blockquote>
&lt;p>对于语意上对于封装性的破坏，书中列出了五种情况，这里有不一一列出了。其实中心思想就是不要让类的内部实现影响外部调用，其中包括外部对类的调用顺序的限制。如果你发现封装的类，从外部调用的时候需要考虑内部实现，这时候其实就是破坏了类的封装性。&lt;/p>
&lt;blockquote>
&lt;p>(Page.142)留意过于紧密的耦合关系&lt;/p>
&lt;/blockquote>
&lt;p>对于耦合的关注，我觉得再怎么强调也不为过。&lt;/p>
&lt;p>对于继承的使用，看完书之后，我的感受是，一定要小心谨慎！书中给出了什么情况下应该使用继承，什么情况下应该使用包含(Page.149)：&lt;/p>
&lt;ul>
&lt;li>如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象。&lt;/li>
&lt;li>如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序。&lt;/li>
&lt;li>如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而来，并在基类里定义共用的数据和子程序。&lt;/li>
&lt;li>当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含。&lt;/li>
&lt;/ul>
&lt;p>对于上面的规则，我的总结了一下，只要涉及到控制接口的就选择继承，只涉及数据的就用包含。&lt;/p>
&lt;p>本章后面说了下创建类的原因，基本上都是一些原则性的指导。并在随后给出了三类应该避免的类(Page.155)：&lt;/p>
&lt;ul>
&lt;li>避免创建万能类(god class)&lt;/li>
&lt;li>消除无关紧要的类&lt;/li>
&lt;li>避免用动词命名的类&lt;/li>
&lt;/ul>
&lt;h2 id="第七章高质量的子程序">第七章－高质量的子程序&lt;/h2>
&lt;p>这一章整体在讲如何设计好的子程序。比如本章的第一节讨论了创建子程序的正当理由，说了几点为什么要创建子程序，目的是什么，创建子程序解决了什么问题。随后书中描述了如何设计合理的子程序。不过，我觉得对于书中讨论的关于子程序可以写多长觉得蛮好玩的，作者的观点是，如果编写了一段超过 200 行代码的子程序，那你就应该小心了。说到这里，我想起在我刚开始写程序的时候，隐约记得写过一个远比 200 行长的多的函数，具体几行忘记了，只记得很长很长，而且方法的参数有输入也有输出，最蛋疼的是没有给出哪几个参数是输出，哪几个参数是输入。现在想想，基本上这个方法只有我会调用，(￣ ▽ ￣) 。&lt;/p>
&lt;p>对于子程序的参数，书中也做了讨论，并明确指出把子程序的参数个数限制在大约 7 个以内，并要求采用某种表示输入、修改、输出的命名规则。&lt;/p>
&lt;p>书中对于函数和过程给出简单的区分。&lt;/p>
&lt;blockquote>
&lt;p>(Page.181)函数是指有返回值的子程序；过程是指没有返回值的子程序&lt;/p>
&lt;/blockquote>
&lt;p>不过在 C++ 中，通常把所有子程序都称为“函数”；返回值类型为 &lt;!-- raw HTML omitted -->void&lt;!-- raw HTML omitted --> 的函数在语义上其实就是过程。关于宏的使用，很明确，尽量少用，尤其是宏子程序。至于内联子程序，作者的建议是节制使用，因为内联子程序违反了封装原则。&lt;/p>
&lt;h2 id="第八章防御式编程">第八章－防御式编程&lt;/h2>
&lt;p>对于防御式编程来说，重点还是讨论了断言。&lt;/p>
&lt;blockquote>
&lt;p>(Page.189)断言为真，则表明程序运行正常，而断言为假，则意味着它已经在代码中发现了意料之外的错误。&lt;/p>
&lt;/blockquote>
&lt;p>至于断言和错误处理的使用的指导建议是，&lt;/p>
&lt;blockquote>
&lt;p>(Page.191)用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况&lt;/p>
&lt;/blockquote>
&lt;p>对于错误处理技术的使用，根据不同的使用场景给出了不同的建议。例如医疗设备控制软件，如果发生了医疗故障，为了保证患者的安全，应该立刻关闭程序等。防御式编程全部的重点在于防御那些未曾预料到的错误。&lt;/p>
&lt;p>本章随后讨论了异常。对于异常的使用给出了几条建议。例如，&lt;/p>
&lt;blockquote>
&lt;p>(Page.199)不能用异常来推卸责任&lt;/p>
&lt;/blockquote>
&lt;p>其实就是说，哪里出现了问题就在哪里解决，不要让规避问题的存在，或者说是遮掩问题。&lt;/p>
&lt;blockquote>
&lt;p>不要在构造函数和析构函数中使用异常，除非你在同一地方把它们捕获&lt;/p>
&lt;/blockquote>
&lt;p>在构造函数中处理异常会让问题变的很麻烦，其中最重要的问题就是资源的泄漏问题。&lt;/p>
&lt;p>书中提到了隔栏(barricade)这个词。并定义说&lt;/p>
&lt;blockquote>
&lt;p>(Page.203)是一种容损策略(damage-cotainment strategy)。&lt;/p>
&lt;/blockquote>
&lt;p>我觉得目的就是为了把错误引起的损失控制在一定范围内。&lt;/p>
&lt;p>书中其它部分谈到了几点关于产品发布和开发过程中，调试代码如何进行权衡。&lt;/p>
&lt;h2 id="第九章伪代码编程过程">第九章－伪代码编程过程&lt;/h2>
&lt;p>其实，我觉得本章没什么特别要说的，因为我觉得伪代码编程属于开发方法学，而且这种方法是作者比较认可的方法，但是不同的项目可能需要不同的方法作开发，不一定所有项目都要用伪代码编程。例如，重构。&lt;/p>
&lt;p>不过，通过了解伪代码编程，然后再跳出整个软件开发的框框，我觉得写代码真成为了软件开发中一个不应该占用很多时间的一个环节。通过编写伪代码，可以把你的思路完全展现出来，作者的观点也很明确，当你什么时候发现伪代码已经无法更改的时候，再开始写真正的代码。由此可见，写真正的代码，在这个开发模式中，占用的比例就非常的小。当然，这么做可以很明显的感觉到，真正写实现代码的时候会比较容易，其实思路和框架都有了，只剩下了代码实现。至此，又让我想到关于复杂度的控制。通过这个环节，可以把代码出错的几率压缩到最低，从这一点来看，其实编写伪代码是一个非常重要的环节，它能有效的控制代码的复杂度。&lt;/p>
&lt;p>至此，第二部分基本上就大概总结了下，其实很多点需要不断的在实践中去尝试，总结写下来只是学的第一步，真正能够融会贯通才算是学到手了，你说是吧&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（一）</title><link>https://ohcoder.com/post/2013/03/08/reading-code-complete1/</link><pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/08/reading-code-complete1/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/08/reading-code-complete1/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（一）" />&lt;p>这周开始读《&lt;a class="link" href="http://book.douban.com/subject/1477390/" target="_blank" rel="noopener"
>代码大全(第二版)&lt;/a>》，没什么特别的原因，只是希望能开阔一下眼界，增加一下见识，丰富一下自己内在的知识。面对当前纷乱的技术分支，沉下心来读一读经典的著作，或许可以从中可以找到一些答案。打算每一周看一部分，看了一下目录，本书一共分为七部分。每周看完一部分就写一篇笔记，粗略记录一下自己的理解。&lt;/p>
&lt;p>其实，本书的经典早已不言而喻，所以其中所讲的内容都很经典。在这里只是记录下自己的理解吧。也许现在看起来理解的很幼稚，不过我觉的，应该会随着时间的不断累加，自己会有更多的感悟吧。所以，凡事都有一个开头，对吧。 ^ _ ^&lt;/p>
&lt;h2 id="从前言说起">从前言说起&lt;/h2>
&lt;p>其实，我看书有一个癖好，每本书基本上我都会从前言开始阅读，总是担心会漏掉什么重要内容似的。这本书也不例外，很幸运，有一段话我体会很深&lt;/p>
&lt;blockquote>
&lt;p>(page.xxii)&amp;hellip;因为学习并掌握不止一门语言通常是专业程序员职业生涯中的分水岭。一旦一名程序员意识到编程原则是超越特定语言语法的东西时，通往能够实质地改善编程质量并提高工作效率地知识大门也就向他敞开了。&lt;/p>
&lt;/blockquote>
&lt;p>回顾了一下自己地学习经历，觉得感受还是蛮深刻的。最早开始的时候我只会 C# 一种语言，那两年思想上基本被束缚在了 Windows 平台上，眼睛里只有 C#，而且编程习惯基本上也被束缚在 Visual Studio 工具上，认为编程就应该用 Visual Studio，编程和 VS(Visual Studio)工具绑定到了一起，离开了 VS 工具基本就不会写程序了。我觉得这并不好笑，而且相信很多 Windows 平台的同学还是有这种想法的吧。&lt;/p>
&lt;p>很幸运，三年前有幸接触 C++，算是迈出了只会一门语言这个圈子。不管是从心理上还是技术上都算是往前迈出了一步。自从去年开始使用 Mac，之后不断接触 Linux 相关，之后逐渐逃离 Windows 世界，随后接触了一些新的语言比如面向前端的 &lt;!-- raw HTML omitted -->Dart&lt;!-- raw HTML omitted -->语言，当前侧重于服务器端的&lt;!-- raw HTML omitted -->Golang&lt;!-- raw HTML omitted -->语言，古老的&lt;!-- raw HTML omitted -->Lisp&lt;!-- raw HTML omitted -->语言，年轻的&lt;!-- raw HTML omitted -->Ruby&lt;!-- raw HTML omitted -->语言，当然还有 iOS 开发常用的&lt;!-- raw HTML omitted -->Objective C&lt;!-- raw HTML omitted -->等等。回想了一下，现在基本突破了面对新语言的恐惧感。了解这些语言的过程中除了学习具体的语法以外，也让我逐渐意识到，写程序，其实只要一个好的文本编辑器(例如&lt;!-- raw HTML omitted -->Vim&lt;!-- raw HTML omitted -->或 &lt;a class="link" href="https://github.com/textmate/textmate" target="_blank" rel="noopener"
>Textmate&lt;/a>) 和相应的编译器就可以了。不需要安装一个臃肿而且庞大的图形界面工具。其实想想，编程语言和人类语言统称为语言，只不过一个是面向人的，一个是面向计算机的而已(注：这里面向计算机指的是让计算机执行的角度说的，而不是从让人阅读的角度说的。当然了，写程序当然是让人能够更好的阅读。但前提是计算机得能运行，你说是不？)。多接触一些语言还有一个很好的感受是，当大牛们对一门语言评头论足的时候，你多少也可以产生一点点理性的切身能够体会到的想法(共鸣或反对) ^ _ ^，而不是盲目且木纳的对着大牛们不断的点头(例如某大牛说 VS 工具是反人类的，至少你可以理解他的吐槽点在哪里)。&lt;/p>
&lt;h2 id="第一章欢迎进入软件构建的世界">第一章－欢迎进入软件构建的世界&lt;/h2>
&lt;p>作者一开始列了一个构建软件的步骤清单，随后否定了这个按部就班的固定的步骤，并称其为红头文件。并解释说&lt;/p>
&lt;blockquote>
&lt;p>(page.4) 在不太正规和正规之间找一个平衡点是不容易的……&lt;/p>
&lt;/blockquote>
&lt;p>我想凡是参与过公司项目的同学多少都可以理解其中的意思 y( ^ _ ^ )y。随后强调了软件构建的重要性。&lt;/p>
&lt;h2 id="第二章用隐喻来更充分地理解软件开发">第二章－用隐喻来更充分地理解软件开发&lt;/h2>
&lt;p>看此处之前我是隐隐约约有一种感觉的，但是我不知道应该如何表达。作者用这样一段话比喻软件隐喻像是什么&lt;/p>
&lt;blockquote>
&lt;p>(page.11) 与其说一个软件隐喻像是一张路线图，还不如说它是一盏探照灯。它不会告诉你到哪里去寻找答案，而仅仅是告诉你如何去寻找答案。隐喻的作用更像是启示(heuristic,启发、试探法)，而不是算法(algorithm)。&lt;/p>
&lt;/blockquote>
&lt;p>恰好昨天晚上看到一篇关于&lt;a class="link" href="http://www.cnblogs.com/weidagang2046/archive/2013/02/15/on-interview.html" target="_blank" rel="noopener"
>程序员招聘&lt;/a>的文章，我很赞同文章里的招聘观点。而且我也觉得，通常情况下，决定一款软件是否成功的主要因素并不是某个牛掰的算法。书中的隐喻，我自己的理解是在构建软件过程中对软件的一种需求上的感悟，是非理性的，恰好和算法这种理性思维形成互补，就像阴阳八卦图中的黑白两部分共同构成一个圆一样。不过，我隐约觉得，构建软件过程中隐喻的重要性要高于个别具体算法。&lt;/p>
&lt;p>之后作者针对于软件过程中的隐喻给出了几种不同类型的软件隐喻。我觉得软件的隐喻很耐人寻味，因为它同样突破了固有的计算机领域，同样可以扩展到世间万物，上升到方法论的高度。&lt;/p>
&lt;h2 id="第三章三思而后行前期准备">第三章－三思而后行：前期准备&lt;/h2>
&lt;p>本章主要讲述了构建软件的前期准备工作。针对不同的软件类型，采取不同的准备策略，例如遇到什么样的客户需要制定哪些策略。并用实际的科学数据表明如果前期准备不够充分会由于软件的进度的不同所遭受的损失比例。总之一句话，前期准备是重中之重，并举例说明了软件开发的不同阶段对前期准备会产生哪些影响。我觉得，这些可以起到指导作用，需要很强的实际操作经验才能驾驭或者说熟练的运用，并不是另一个红头文件。之后描述了架构包括哪些具体的内容，需要考虑哪些方面。觉得很多还是需要不断的实践才能深刻的理解其中的意味，单看这些罗列的文字没什么太大的意义。&lt;/p>
&lt;h2 id="第四章关键的构建决策">第四章－关键的“构建”决策&lt;/h2>
&lt;p>这一章主要是构建过程中，编程语言的选择问题。并介绍了几种常见的语言都有哪些特点。书中有一句话让我不太认同&lt;/p>
&lt;blockquote>
&lt;p>(page.66~page.67) &amp;hellip;，我还看到了 Web 的崛起和 Windows 的衰落。我只能假设当你读到这本书的时候，又会有某些新的技术蒸蒸日上，而我今天(2004 年)所知道的 Web 编程将会慢慢消失。这些技术周期(或者说是技术浪潮)意味着不同的编程实践，编程实践取决于你在技术浪潮所处的位置。&lt;/p>
&lt;/blockquote>
&lt;p>很显然，目前来看(2013 年) Web 编程不会消失，而且还会有成为主流的可能。说说我的想法，对于未来移动端会被 Web 取代的这种说法我也不敢完全认同。我认为未来会是移动终端的 UI 加上 Web 的后端会成为主流(或者说是云端？)，因为我认为 Web 的 &lt;!-- raw HTML omitted -->URL&lt;!-- raw HTML omitted --> 对于普通大众来说是使用 Web 的一个门槛，远远没有移动端的 UI 更友好。当然了，我也像作者一样给自己留条后路，我只能假设当你读到此篇博客的时候，又会有某些新的技术蒸蒸日上，而我今天(2013 年)所知道的 Web 的 &lt;!-- raw HTML omitted -->URL&lt;!-- raw HTML omitted --> 会慢慢退化。&lt;/p>
&lt;p>至于书中的语言介绍，我就不总结了，以免招致“杀身之祸”。但作者的一个观点，我觉得非常有启发。引用书中的解释&lt;/p>
&lt;blockquote>
&lt;p>(page.68) gries 对“在一种语言上编程(programming in a language)”和“深入一种语言去编程(programming into a language)”做了区分。“在一种语言上编程”的程序员将他们的思想限制于“语言直接支持的那些构件”。如果语言工具是初级的，那么程序员的思想也是初级的。“深入一种语言去编程”的程序员首先决定他要表达的思想是什么，然后决定如何使用特定语言提供的工具来表达这些思想&lt;/p>
&lt;/blockquote>
&lt;p>其实，我的理解是，要让语言为你的思想服务，而不要让你的思想服务于语言。&lt;/p></description></item></channel></rss>
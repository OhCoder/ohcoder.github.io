<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>读书笔记 on OhCoder</title><link>https://ohcoder.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link><description>Recent content in 读书笔记 on OhCoder</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Mar 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://ohcoder.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>读《代码大全（第二版）》笔记（三）</title><link>https://ohcoder.com/post/2013/03/24/reading-code-complete3/</link><pubDate>Sun, 24 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/24/reading-code-complete3/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/24/reading-code-complete3/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（三）" />&lt;p>继续上一周的阅读，本周读了第三部分－变量。&lt;/p>
&lt;p>整个第三部分，包括第10章到第13章，一共有四章都是围绕变量展开。可见变量在程序设计当中有多重要。&lt;/p>
&lt;h2 id="第十章使用变量的一般事项">第十章－使用变量的一般事项&lt;/h2>
&lt;p>从本章标题中也可以看出，本章主要就是在讲变量的使用。&lt;/p>
&lt;p>本章一开始，作者就提到关于隐式变量声明的观点。例如：&lt;/p>
&lt;blockquote>
&lt;p>(Page.240)隐式变量声明对于任何一种语言来说都是最具危险性的特性之一&lt;/p>
&lt;/blockquote>
&lt;p>作者给出的解决办法是：&lt;/p>
&lt;ul>
&lt;li>关闭隐式声明&lt;/li>
&lt;li>声明全部的变量&lt;/li>
&lt;li>遵循某种命名规则&lt;/li>
&lt;li>检查变量名&lt;/li>
&lt;/ul>
&lt;p>其实，关于这一点，现代解释型脚本语言貌似很多都支持隐式声明，例如&lt;!-- raw HTML omitted -->Javascript&lt;!-- raw HTML omitted -->。但是作者说的并不无道理，我用脚本语言用的还不是很多，没有太多经验来总结其中的利弊，暂且采用作者说的方法。&lt;/p>
&lt;p>在作用域一节中，作者提出了两个概念，一个是&lt;/p>
&lt;blockquote>
&lt;p>(Page.245)跨度*”，另一个是“*(Page.246)存活时间(live time)。&lt;/p>
&lt;/blockquote>
&lt;p>所谓跨度，作者引出了其定义&lt;/p>
&lt;blockquote>
&lt;p>(Page.245)衡量又一个变量的不同引用点的靠近程度的一种方法是计算该变量的“跨度(span)。&lt;/p>
&lt;/blockquote>
&lt;p>所谓存活时间，&lt;/p>
&lt;blockquote>
&lt;p>(Page.246)即一个变量存在期间所跨越的语句总数。&lt;/p>
&lt;/blockquote>
&lt;p>也由此可见，对于变量来说保持跨度值和存活时间尽可能的短是主要目标。&lt;/p>
&lt;p>对于减小变量作用域，作者给出了一些建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.249)在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量&lt;/p>
&lt;/blockquote>
&lt;p>对于这一条建议，作者的目的是能够在循环里正确的使用外部初始化的变量。比如你把一个变量的声明和使用这个变量的循环之间隔离的很远的话，当需要修改循环的时候比较不容易看到循环中使用的这个变量。&lt;/p>
&lt;blockquote>
&lt;p>(Page.249)直到变量即将被使用时再为其赋值&lt;/p>
&lt;/blockquote>
&lt;p>这一条建议，我觉得很容易理解，主要就是为了让代码的初始化更醒目。&lt;/p>
&lt;blockquote>
&lt;p>(Page.250)当对变量的作用域犹豫不决的时候，你应该倾向于选择该变量所能具有的最小作用域&lt;/p>
&lt;/blockquote>
&lt;p>这条建议，其实目的也是为了尽可能的降低变量的生存时间。&lt;/p>
&lt;blockquote>
&lt;p>(Page.252)采用越晚的绑定时间会越有利&lt;/p>
&lt;/blockquote>
&lt;p>关于绑定时间书中给出了三种情况：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Java示例：在编写代码时绑定其值的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">titleBar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0xFF&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="c1">//0xFF is hex value for color blue
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Java示例：在编译时绑定其值的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">COLOR_BLUE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0xFF&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">TITLE_BAR_COLOR&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">COLOR_BLUE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">titleBar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TITLE_BAR_COLOR&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Java示例：在运行时绑定其值的变量 titleBar.color =
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">ReadTitleBarColor&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关于这一点就不多做解释了。示例已经说明问题了。&lt;/p>
&lt;h2 id="第十一章变量名的力量">第十一章－变量名的力量&lt;/h2>
&lt;p>全章讲述的是变量命名，对于大的项目而言，好的变量名不但使程序更容易读懂和编写，而且还利于以后的bug调试。&lt;/p>
&lt;p>对于如何命名，书中提到了一点建议，我觉得之前可能做的也不太好。&lt;/p>
&lt;blockquote>
&lt;p>(Page.261)一个好记的名字反映的通常都是问题，而不是解决方案。一个好名字通常表达的是“什么”(what)，而不是“如何”(how)。&lt;/p>
&lt;/blockquote>
&lt;p>作者说，&lt;/p>
&lt;blockquote>
&lt;p>(Page.261)一般而言，如果一个名字反映了计算的某些方面而不是问题本身，那么它反映的就是“how”而非“what”了。&lt;/p>
&lt;/blockquote>
&lt;p>关于名字的长度，文中提到&lt;/p>
&lt;blockquote>
&lt;p>(Page.262)当变量名的平均长度在10到16个字符的时候，调试程序所需花费的力气是最小的(1990)。&lt;/p>
&lt;/blockquote>
&lt;p>其实，我觉得， &lt;!-- raw HTML omitted -->Objective
C&lt;!-- raw HTML omitted --> 这门语言天生就挺符合这个要求的，不用你刻意去注意，哈哈。&lt;/p>
&lt;p>对于变量中使用计算限定词，文中也给出了很好的建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.263)如果你要用类似与Total、Sum、Average、Max、Min、Record、String、Pointer这样的限定词来修改某个名字，那么请记住把限定词加到限定词名字的最后。&lt;/p>
&lt;/blockquote>
&lt;p>对于文中所说何时采用命名规则，我觉得，平时就养成这个习惯吧，不论怎样，这个习惯都不是一个坏习惯。&lt;/p>
&lt;p>与语言无关的命名规则的指导原则，书中也给出了几种方案(Page.272)。&lt;/p>
&lt;p>&lt;strong>方案1&lt;/strong>: 通过大写字母开头区分类型和变量，例如： &lt;!-- raw HTML omitted -->Widget 与 widget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LongerWidget 与 longerWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案2&lt;/strong>: 通过全部大写区分类型和变量，例如： &lt;!-- raw HTML omitted -->WIDGET 与 widget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LONGERWIDGET 与 longerWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案3&lt;/strong>: 通过给类型“t_”前缀区分类型和变量，例如： &lt;!-- raw HTML omitted -->t_Widget 与 widget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->t_LongerWidget 与 LongerWidger;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案4&lt;/strong>: 通过给变量“a”前缀区分类型和变量，例如： &lt;!-- raw HTML omitted -->Widget 与 aWidget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LongerWidget 与 aLongWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>方案5&lt;/strong>: 通过对变量采用更明确的名字区分类型和变量，例如： &lt;!-- raw HTML omitted -->Widget 与 employeeWidget;&lt;!-- raw HTML omitted --> &lt;!-- raw HTML omitted -->LongerWidget  与fullEmployeeWidget;&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>书中对每一种方案的优缺点做了描述(Page.272~Page.273)：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>第一种方案是在大小写敏感语言如 C++ 和 Java 里常用的规则，但是有些程序员对仅依靠大小写区分名字感到不大舒服。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第二种方案使类型名和变量名之间的差异更加鲜明。然而，由于历史原因，在 C++ 和 Java 里面全部字母大写只用于表示常量，同时这种方案也会与第一种方案一样面临混合语言环境的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第三种方案可用于所有语言，但是很多程序员从审美的角度出发并不喜欢增加前缀。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第四种方案有时会用作第三种方案的备选项，但是它存在的问题是需要改变类的每个实例的名字，而不是仅仅修改类名。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第五种方案要求基于每个变量的实际情况作出更多的考虑。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>本章后面说了下应该避免的命名指导原则，原则有很多，我觉得都是非常常见的命名错误，在这里就不罗列了。&lt;/p>
&lt;h2 id="第十二章基本数据类型">第十二章－基本数据类型&lt;/h2>
&lt;p>本章对每一种基本数据类型的使用进行了详细讲解。首先从全局上给出了一些建议(Page.292~Page.293)。&lt;/p>
&lt;ul>
&lt;li>避免使用“神秘数值(magic number)” 。如果需要，可以使用硬编码的 0 和 1&lt;/li>
&lt;li>预防除零(devide-by-zero)错误，使类型转换变得明显。&lt;/li>
&lt;li>避免混合类型的比较，注意编译器的警告。&lt;/li>
&lt;/ul>
&lt;p>本章后面的基本类型差不多都是围绕着上面这几点根据具体的类型特点展开来讲的。其中印象比较深刻的是关于浮点数的一条建议：&lt;/p>
&lt;blockquote>
&lt;p>(Page.295)避免等量判断&lt;/p>
&lt;/blockquote>
&lt;p>很早之前掉进过这个坑。记得当时用了两个浮点数值进行等值判断，结果相等的概率非常的低，后来打印了一下数值，才发现掉到坑去里了，后来就长记性了，呵呵。&lt;/p>
&lt;p>对于&lt;!-- raw HTML omitted -->C&lt;!-- raw HTML omitted -->语言的字符串的使用，有几个建议印象比较深刻。&lt;/p>
&lt;blockquote>
&lt;p>(Page.299)把C-Style字符串的长度声明为CONSTANT + 1&lt;/p>
&lt;/blockquote>
&lt;p>这一条建议可以避免循环数组时越界，当然这种写法在很多算法书中也很常见。&lt;/p>
&lt;blockquote>
&lt;p>(Page.300)用null初始化字符串以避免无结束符的字符串&lt;/p>
&lt;/blockquote>
&lt;p>这条在平时初始化的时候也很受用。下面这条是关于分配内存并初始化的建议。&lt;/p>
&lt;blockquote>
&lt;p>(Page.300)其次，在你动态分配字符串的时候，使用calloc()而不是malloc()来把它初始化为0。calloc()会负责分配内存，并把它初始化为0。malloc()只分配内存，并不执行初始化。……&lt;/p>
&lt;/blockquote>
&lt;p>对于定义枚举类型，文中给出了两条之前没有注意的点。&lt;/p>
&lt;blockquote>
&lt;p>(Page.305)定义出枚举的第一项和最后一项，以便用于循环边界&lt;/p>
&lt;/blockquote>
&lt;p>这一点以前还真没注意过，以后要注意了。还有下一点，我觉得也是蛮有道理的，虽然表面上感觉有点小聪明的意思，呵呵。&lt;/p>
&lt;blockquote>
&lt;p>(Page.305)把枚举类型的第一个元素留作非法值&lt;/p>
&lt;/blockquote>
&lt;p>本章后面谈论了一下使用&lt;!-- raw HTML omitted -->typedef&lt;!-- raw HTML omitted -->进行自定义类型，感觉没有太多要说的。&lt;/p>
&lt;h2 id="第十三章不常见的数据类型">第十三章－不常见的数据类型&lt;/h2>
&lt;p>本章主要是在讲非基本数据类型。主要包括结构、指针、全局数据。其实，关于这一章里，结构没有什么好说的，很多常见的语法书中该说的基本都说到了，包括结构化数据的优点等。关于 &lt;!-- raw HTML omitted -->C/C++&lt;!-- raw HTML omitted --> 语言指针部分，其实很多基本概念在一些权威的书中基本也都提到过，没什么感觉。最后的讲了全局数据，当然主要就是全局数据的弊端占用了很多篇幅，以及如何避免使用全局数据等。避免的方式，感觉还是通过重构，尽量使程序模块化，降低变量的生存时间，也避免在内存堆中分配空间，达到节省内存的目的等等。&lt;/p>
&lt;p>总体来说，这部分的内容不少，但是有些知识已经在一些权威的语法书中能够找到，读起来相对来说没有前两部分难懂，可能有些问题是平时写程序的时候经常会碰到的原因吧，见的多了，神经就有点麻木了，呵呵。&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（二）</title><link>https://ohcoder.com/post/2013/03/17/reading-code-complete2/</link><pubDate>Sun, 17 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/17/reading-code-complete2/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/17/reading-code-complete2/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（二）" />&lt;p>本周读了第二部分－&lt;strong>创建高质量的代码&lt;/strong>。&lt;/p>
&lt;p>说实话，真的好后悔没有早点读这本书，觉得自己以前写的代码就是一坨&lt;!-- raw HTML omitted -->Shǐ&lt;!-- raw HTML omitted -->。看书的过程中，一边看就觉得后脊梁发凉，一阵阵凉风从后背吹过……&lt;/p>
&lt;p>本部分分为五章，基本上还是从顶层设计角度探讨了如何更好的编写代码。分别从软件的设计、类的封装、子程序的设计以及防御式编程和使用伪代码进行开发方法方面进行了探讨。感觉书中需要学习点太多了，好多方面看完之后都有感触。想了想，如果都列出来感觉可以写一本小册子了，所以在这里还是随意挑几个标题大(Y( ^ _ ^ )Y)的记录一下吧，太细的点就不列了。不过虽然有的点不是大标题，但并不代表这些点不重要，有时间的话，我想我还会经常回过头来当手册来翻一翻的。&lt;/p>
&lt;h2 id="第五章软件创建中的设计">第五章－软件创建中的设计&lt;/h2>
&lt;p>本章的一个核心思想是如何更合理的控制复杂度。&lt;/p>
&lt;blockquote>
&lt;p>(Page.77)软件的首要技术使命：管理复杂度&lt;/p>
&lt;/blockquote>
&lt;p>书中首先阐述了管理复杂度的重要性，并指出产生高代价、低效率的设计源于下面三种根源：&lt;/p>
&lt;ul>
&lt;li>用复杂的方法解决简单的问题；&lt;/li>
&lt;li>用简单但错误的方法解决复杂的问题；&lt;/li>
&lt;li>用不恰当的复杂方法解决复杂的问题。&lt;/li>
&lt;/ul>
&lt;p>关于这一点，书中描述了两种方法来解决这个问题：&lt;/p>
&lt;ul>
&lt;li>把任何人在同一时间需要处理的本质（essential）复杂度的量减到最少；&lt;/li>
&lt;li>不要让偶然性（accidental）的复杂度无谓地快速增长。&lt;/li>
&lt;/ul>
&lt;p>关于如何控制复杂度这个问题，看了下整本书的目录，不管是从顶层对软件的设计，还是深入到底层的代码编写，貌似都是为了更好的控制复杂度，不过我整本书还没看完，只是感觉而已。&lt;/p>
&lt;p>回过头来想了想，在我曾经做过的项目中。虽然有的项目外表上看起来算是完成了，不过我感觉，在做项目的过程中，多少都冒犯了上面指出的三种根源。只不过上面总结的很抽象，具体实施起来会涉及到很多方面。呵呵，这当然是一个复杂的问题。&lt;/p>
&lt;p>随后，书中说了理想的设计特征包括哪些范畴：&lt;/p>
&lt;ul>
&lt;li>最小的复杂度（Minimal complexity）&lt;/li>
&lt;li>易于维护（Ease of maintenance）&lt;/li>
&lt;li>松散耦合（loose coupling）&lt;/li>
&lt;li>可扩展性（extensibility）&lt;/li>
&lt;li>高扇入（high fan-in）&lt;/li>
&lt;li>低扇出（low fan-out）&lt;/li>
&lt;li>可移植性（portability）&lt;/li>
&lt;li>精简性（leanness）&lt;/li>
&lt;li>层次性（stratification）&lt;/li>
&lt;li>标准技术（Standard techniques）&lt;/li>
&lt;/ul>
&lt;p>其中，关于最小的复杂度部分，我觉得书中有一句话说的很形象。&lt;/p>
&lt;blockquote>
&lt;p>(Page.80)如果你的设计方案不能让你在专注于程序的一部分时安心地忽视其他部分地话，这一设计就没有什么作用了。&lt;/p>
&lt;/blockquote>
&lt;p>精简性方面，书中指出&lt;/p>
&lt;blockquote>
&lt;p>(Page.81)精简性意味着设计出的系统没有多余的部分(Wirth 1995,McConnell 1997)。&lt;/p>
&lt;/blockquote>
&lt;p>除此之外，对于高扇入和低扇出，其实之前貌似重视不够，尤其是低扇出，以后要注意这一点了，至于其他方面，平时看的也比较多，应该还算是不陌生吧。&lt;/p>
&lt;p>书中后面讲到隐藏秘密(信息隐藏)。这其中主要分为了两大类：&lt;/p>
&lt;ul>
&lt;li>隐藏复杂度&lt;/li>
&lt;li>隐藏变化源&lt;/li>
&lt;/ul>
&lt;p>老实说，看过这部分之后，回想了下之前写过的代码，我觉得做的很不够，和书中所描述的点相差甚远，真是觉得汗颜。也感觉到设计好的接口是如此之难，能够设计好的接口真不是简单吹吹牛就能做好的，需要多方面的综合考虑才有可能更合理的对接口进行设计。&lt;/p>
&lt;p>对于设计模式的用处，书中列出了设计模式的几个益处，我想根据这几个点，多少也可以指导我们平时如何更合理的使用设计模式吧。&lt;/p>
&lt;ul>
&lt;li>设计模式通过提供现成的抽象来减少复杂度&lt;/li>
&lt;li>设计模式通过把常见解决方案的细节予以制度化来减少出错&lt;/li>
&lt;li>设计模式通过提供多种设计方案而带来启发性的价值&lt;/li>
&lt;li>设计模式通过把设计对话提升到一个更高的层次上来简化交流&lt;/li>
&lt;/ul>
&lt;p>对于这几个益处，针对设计模式，我觉得，设计模式仅仅是一种框架，可以用来降低复杂度，减少错误，可以依赖这些模式做一些变化来适应需要解决的问题，最后是利于码农之间更好的交流。所以从这几个方面看，学习设计模式一定不要死记硬背，更好的掌握使用这些模式的场景更重要，所谓手中无剑，心中也无剑，此为高手。&lt;/p>
&lt;p>关于这章的其他部分提了一些具体实践的方法，说了一些方法论，和具体实践结合很紧密。关于保持松散耦合这方面，书中也提了哪些方面可能会产生耦合，以及耦合常见的形式。&lt;/p>
&lt;p>本章后面讨论了一下自上而下和自下而上的设计方法。作者的结论是，两种方式各有利弊，并非排斥关系。自上而下从一般性的问题出发，把该问题分解成可控的部分。而自下而上从可控的部分出发，去构造一个适用的方案。这两种方法都有各自的强项和弱项。设计过程中，你会受益于二者的相互协作。&lt;/p>
&lt;h2 id="第六章可以工作的类">第六章－可以工作的类&lt;/h2>
&lt;p>本章讨论了设计类的接口。书中给出了几个C++的代码例子，以说明良好的接口应该如何设计。书中有几个点很有启发性，其中有一句是&lt;/p>
&lt;blockquote>
&lt;p>(Page.138)关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计&lt;/p>
&lt;/blockquote>
&lt;p>对于类进行良好的封装，作者给出了几条建议：&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)尽可能地限制类和成员的可访问性&lt;/p>
&lt;/blockquote>
&lt;p>关于这条建议，书中引用了Meyers的一句话，&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)应该采用最严格且可行的访问级别(Meyers 1998,Block 2001)。&lt;/p>
&lt;/blockquote>
&lt;p>意思很明显，就是说，如果你不确定，那么多隐藏通常比少隐藏要好。&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)不要公开暴露成员数据&lt;/p>
&lt;/blockquote>
&lt;p>这一点很明显，暴露成员数据会破坏封装性。这一点对于 C++ 来说更应该注意，因为对于 &lt;!-- raw HTML omitted -->C#&lt;!-- raw HTML omitted --> 和 &lt;!-- raw HTML omitted -->Java&lt;!-- raw HTML omitted --> 来说都有对应的访问器来隐藏成员数据，而 &lt;!-- raw HTML omitted -->Objective C&lt;!-- raw HTML omitted -->，则会对每个向外暴露的成员同样也会生成对应 &lt;!-- raw HTML omitted -->Set&lt;!-- raw HTML omitted --> 和 &lt;!-- raw HTML omitted -->Get&lt;!-- raw HTML omitted --> 方法。呃，对于语言的讨论就此打住吧&amp;hellip;&amp;hellip;&lt;/p>
&lt;blockquote>
&lt;p>(Page.139)避免把私用的实现细节放入类的接口中&lt;/p>
&lt;/blockquote>
&lt;p>对于这一点，原来一起工作的同事有讨论过相关的问题。对于这一点《&lt;a class="link" href="http://book.douban.com/subject/5387403/" target="_blank" rel="noopener"
>Effective C++&lt;/a>》书中也有详细讨论，具体的可以翻一翻这本书。另外，这一点感觉也是&lt;!-- raw HTML omitted -->C++&lt;!-- raw HTML omitted -->的一个坑，其他语言应该可以比较容易的规避这个问题。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)不要对类的使用者做出任何假设&lt;/p>
&lt;/blockquote>
&lt;p>关于这一点，我想没什么好解释的，很显然的事情。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)避免使用友元类(friend class)&lt;/p>
&lt;/blockquote>
&lt;p>书中说到，&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)一般情况下友元类会破坏封装，因为它让你在同一时刻需要考虑更多的代码量，从而增加了复杂度。&lt;/p>
&lt;p>(Page.141)不要因为一个子程序里仅使用公用子程序，就把它归入公开接口&lt;/p>
&lt;/blockquote>
&lt;p>这一点考虑的问题是，如果把某个子程序暴露给外界后，接口所展示的抽象是否还能保持一致。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)让阅读代码比编写代码更方便&lt;/p>
&lt;/blockquote>
&lt;p>关于这一点，书中强调还是代码的可读性。时刻要防止接口设计的一致性问题，一旦出现接口定义不规范的问题后，不但开始影响代码的可读性，而且还有可能会出现《&lt;a class="link" href="http://book.douban.com/subject/1152111/" target="_blank" rel="noopener"
>程序员修炼之道&lt;/a>》中所说的破窗户问题。&lt;/p>
&lt;blockquote>
&lt;p>(Page.141)要格外警惕从语意破坏封装性&lt;/p>
&lt;/blockquote>
&lt;p>对于语意上对于封装性的破坏，书中列出了五种情况，这里有不一一列出了。其实中心思想就是不要让类的内部实现影响外部调用，其中包括外部对类的调用顺序的限制。如果你发现封装的类，从外部调用的时候需要考虑内部实现，这时候其实就是破坏了类的封装性。&lt;/p>
&lt;blockquote>
&lt;p>(Page.142)留意过于紧密的耦合关系&lt;/p>
&lt;/blockquote>
&lt;p>对于耦合的关注，我觉得再怎么强调也不为过。&lt;/p>
&lt;p>对于继承的使用，看完书之后，我的感受是，一定要小心谨慎！书中给出了什么情况下应该使用继承，什么情况下应该使用包含(Page.149)：&lt;/p>
&lt;ul>
&lt;li>如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象。&lt;/li>
&lt;li>如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序。&lt;/li>
&lt;li>如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而来，并在基类里定义共用的数据和子程序。&lt;/li>
&lt;li>当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含。&lt;/li>
&lt;/ul>
&lt;p>对于上面的规则，我的总结了一下，只要涉及到控制接口的就选择继承，只涉及数据的就用包含。&lt;/p>
&lt;p>本章后面说了下创建类的原因，基本上都是一些原则性的指导。并在随后给出了三类应该避免的类(Page.155)：&lt;/p>
&lt;ul>
&lt;li>避免创建万能类(god class)&lt;/li>
&lt;li>消除无关紧要的类&lt;/li>
&lt;li>避免用动词命名的类&lt;/li>
&lt;/ul>
&lt;h2 id="第七章高质量的子程序">第七章－高质量的子程序&lt;/h2>
&lt;p>这一章整体在讲如何设计好的子程序。比如本章的第一节讨论了创建子程序的正当理由，说了几点为什么要创建子程序，目的是什么，创建子程序解决了什么问题。随后书中描述了如何设计合理的子程序。不过，我觉得对于书中讨论的关于子程序可以写多长觉得蛮好玩的，作者的观点是，如果编写了一段超过 200 行代码的子程序，那你就应该小心了。说到这里，我想起在我刚开始写程序的时候，隐约记得写过一个远比 200 行长的多的函数，具体几行忘记了，只记得很长很长，而且方法的参数有输入也有输出，最蛋疼的是没有给出哪几个参数是输出，哪几个参数是输入。现在想想，基本上这个方法只有我会调用，(￣▽￣) 。&lt;/p>
&lt;p>对于子程序的参数，书中也做了讨论，并明确指出把子程序的参数个数限制在大约7个以内，并要求采用某种表示输入、修改、输出的命名规则。&lt;/p>
&lt;p>书中对于函数和过程给出简单的区分。&lt;/p>
&lt;blockquote>
&lt;p>(Page.181)函数是指有返回值的子程序；过程是指没有返回值的子程序&lt;/p>
&lt;/blockquote>
&lt;p>不过在 C++ 中，通常把所有子程序都称为“函数”；返回值类型为 &lt;!-- raw HTML omitted -->void&lt;!-- raw HTML omitted --> 的函数在语义上其实就是过程。关于宏的使用，很明确，尽量少用，尤其是宏子程序。至于内联子程序，作者的建议是节制使用，因为内联子程序违反了封装原则。&lt;/p>
&lt;h2 id="第八章防御式编程">第八章－防御式编程&lt;/h2>
&lt;p>对于防御式编程来说，重点还是讨论了断言。&lt;/p>
&lt;blockquote>
&lt;p>(Page.189)断言为真，则表明程序运行正常，而断言为假，则意味着它已经在代码中发现了意料之外的错误。&lt;/p>
&lt;/blockquote>
&lt;p>至于断言和错误处理的使用的指导建议是，&lt;/p>
&lt;blockquote>
&lt;p>(Page.191)用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况&lt;/p>
&lt;/blockquote>
&lt;p>对于错误处理技术的使用，根据不同的使用场景给出了不同的建议。例如医疗设备控制软件，如果发生了医疗故障，为了保证患者的安全，应该立刻关闭程序等。防御式编程全部的重点在于防御那些未曾预料到的错误。&lt;/p>
&lt;p>本章随后讨论了异常。对于异常的使用给出了几条建议。例如，&lt;/p>
&lt;blockquote>
&lt;p>(Page.199)不能用异常来推卸责任&lt;/p>
&lt;/blockquote>
&lt;p>其实就是说，哪里出现了问题就在哪里解决，不要让规避问题的存在，或者说是遮掩问题。&lt;/p>
&lt;blockquote>
&lt;p>不要在构造函数和析构函数中使用异常，除非你在同一地方把它们捕获&lt;/p>
&lt;/blockquote>
&lt;p>在构造函数中处理异常会让问题变的很麻烦，其中最重要的问题就是资源的泄漏问题。&lt;/p>
&lt;p>书中提到了隔栏(barricade)这个词。并定义说&lt;/p>
&lt;blockquote>
&lt;p>(Page.203)是一种容损策略(damage-cotainment strategy)。&lt;/p>
&lt;/blockquote>
&lt;p>我觉得目的就是为了把错误引起的损失控制在一定范围内。&lt;/p>
&lt;p>书中其它部分谈到了几点关于产品发布和开发过程中，调试代码如何进行权衡。&lt;/p>
&lt;h2 id="第九章伪代码编程过程">第九章－伪代码编程过程&lt;/h2>
&lt;p>其实，我觉得本章没什么特别要说的，因为我觉得伪代码编程属于开发方法学，而且这种方法是作者比较认可的方法，但是不同的项目可能需要不同的方法作开发，不一定所有项目都要用伪代码编程。例如，重构。&lt;/p>
&lt;p>不过，通过了解伪代码编程，然后再跳出整个软件开发的框框，我觉得写代码真成为了软件开发中一个不应该占用很多时间的一个环节。通过编写伪代码，可以把你的思路完全展现出来，作者的观点也很明确，当你什么时候发现伪代码已经无法更改的时候，再开始写真正的代码。由此可见，写真正的代码，在这个开发模式中，占用的比例就非常的小。当然，这么做可以很明显的感觉到，真正写实现代码的时候会比较容易，其实思路和框架都有了，只剩下了代码实现。至此，又让我想到关于复杂度的控制。通过这个环节，可以把代码出错的几率压缩到最低，从这一点来看，其实编写伪代码是一个非常重要的环节，它能有效的控制代码的复杂度。&lt;/p>
&lt;p>至此，第二部分基本上就大概总结了下，其实很多点需要不断的在实践中去尝试，总结写下来只是学的第一步，真正能够融会贯通才算是学到手了，你说是吧&lt;/p></description></item><item><title>读《代码大全（第二版）》笔记（一）</title><link>https://ohcoder.com/post/2013/03/08/reading-code-complete1/</link><pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/03/08/reading-code-complete1/</guid><description>&lt;img src="https://ohcoder.com/post/2013/03/08/reading-code-complete1/title.jpg" alt="Featured image of post 读《代码大全（第二版）》笔记（一）" />&lt;p>这周开始读《&lt;a class="link" href="http://book.douban.com/subject/1477390/" target="_blank" rel="noopener"
>代码大全(第二版)&lt;/a>》，没什么特别的原因，只是希望能开阔一下眼界，增加一下见识，丰富一下自己内在的知识。面对当前纷乱的技术分支，沉下心来读一读经典的著作，或许可以从中可以找到一些答案。打算每一周看一部分，看了一下目录，本书一共分为七部分。每周看完一部分就写一篇笔记，粗略记录一下自己的理解。&lt;/p>
&lt;p>其实，本书的经典早已不言而喻，所以其中所讲的内容都很经典。在这里只是记录下自己的理解吧。也许现在看起来理解的很幼稚，不过我觉的，应该会随着时间的不断累加，自己会有更多的感悟吧。所以，凡事都有一个开头，对吧。 ^ _ ^&lt;/p>
&lt;h2 id="从前言说起">从前言说起&lt;/h2>
&lt;p>其实，我看书有一个癖好，每本书基本上我都会从前言开始阅读，总是担心会漏掉什么重要内容似的。这本书也不例外，很幸运，有一段话我体会很深&lt;/p>
&lt;blockquote>
&lt;p>(page.xxii)&amp;hellip;因为学习并掌握不止一门语言通常是专业程序员职业生涯中的分水岭。一旦一名程序员意识到编程原则是超越特定语言语法的东西时，通往能够实质地改善编程质量并提高工作效率地知识大门也就向他敞开了。&lt;/p>
&lt;/blockquote>
&lt;p>回顾了一下自己地学习经历，觉得感受还是蛮深刻的。最早开始的时候我只会 C# 一种语言，那两年思想上基本被束缚在了 Windows 平台上，眼睛里只有 C#，而且编程习惯基本上也被束缚在 Visual Studio 工具上，认为编程就应该用 Visual Studio，编程和 VS(Visual Studio)工具绑定到了一起，离开了 VS 工具基本就不会写程序了。我觉得这并不好笑，而且相信很多 Windows 平台的同学还是有这种想法的吧。&lt;/p>
&lt;p>很幸运，三年前有幸接触 C++，算是迈出了只会一门语言这个圈子。不管是从心理上还是技术上都算是往前迈出了一步。自从去年开始使用 Mac，之后不断接触 Linux 相关，之后逐渐逃离 Windows 世界，随后接触了一些新的语言比如面向前端的 &lt;!-- raw HTML omitted -->Dart&lt;!-- raw HTML omitted -->语言，当前侧重于服务器端的&lt;!-- raw HTML omitted -->Golang&lt;!-- raw HTML omitted -->语言，古老的&lt;!-- raw HTML omitted -->Lisp&lt;!-- raw HTML omitted -->语言，年轻的&lt;!-- raw HTML omitted -->Ruby&lt;!-- raw HTML omitted -->语言，当然还有 iOS 开发常用的&lt;!-- raw HTML omitted -->Objective C&lt;!-- raw HTML omitted -->等等。回想了一下，现在基本突破了面对新语言的恐惧感。了解这些语言的过程中除了学习具体的语法以外，也让我逐渐意识到，写程序，其实只要一个好的文本编辑器(例如&lt;!-- raw HTML omitted -->Vim&lt;!-- raw HTML omitted -->或 &lt;a class="link" href="https://github.com/textmate/textmate" target="_blank" rel="noopener"
>Textmate&lt;/a>) 和相应的编译器就可以了。不需要安装一个臃肿而且庞大的图形界面工具。其实想想，编程语言和人类语言统称为语言，只不过一个是面向人的，一个是面向计算机的而已(注：这里面向计算机指的是让计算机执行的角度说的，而不是从让人阅读的角度说的。当然了，写程序当然是让人能够更好的阅读。但前提是计算机得能运行，你说是不？)。多接触一些语言还有一个很好的感受是，当大牛们对一门语言评头论足的时候，你多少也可以产生一点点理性的切身能够体会到的想法(共鸣或反对) ^ _ ^，而不是盲目且木纳的对着大牛们不断的点头(例如某大牛说 VS 工具是反人类的，至少你可以理解他的吐槽点在哪里)。&lt;/p>
&lt;h2 id="第一章欢迎进入软件构建的世界">第一章－欢迎进入软件构建的世界&lt;/h2>
&lt;p>作者一开始列了一个构建软件的步骤清单，随后否定了这个按部就班的固定的步骤，并称其为红头文件。并解释说&lt;/p>
&lt;blockquote>
&lt;p>(page.4) 在不太正规和正规之间找一个平衡点是不容易的……&lt;/p>
&lt;/blockquote>
&lt;p>我想凡是参与过公司项目的同学多少都可以理解其中的意思y( ^ _ ^ )y。随后强调了软件构建的重要性。&lt;/p>
&lt;h2 id="第二章用隐喻来更充分地理解软件开发">第二章－用隐喻来更充分地理解软件开发&lt;/h2>
&lt;p>看此处之前我是隐隐约约有一种感觉的，但是我不知道应该如何表达。作者用这样一段话比喻软件隐喻像是什么&lt;/p>
&lt;blockquote>
&lt;p>(page.11) 与其说一个软件隐喻像是一张路线图，还不如说它是一盏探照灯。它不会告诉你到哪里去寻找答案，而仅仅是告诉你如何去寻找答案。隐喻的作用更像是启示(heuristic,启发、试探法)，而不是算法(algorithm)。&lt;/p>
&lt;/blockquote>
&lt;p>恰好昨天晚上看到一篇关于&lt;a class="link" href="http://www.cnblogs.com/weidagang2046/archive/2013/02/15/on-interview.html" target="_blank" rel="noopener"
>程序员招聘&lt;/a>的文章，我很赞同文章里的招聘观点。而且我也觉得，通常情况下，决定一款软件是否成功的主要因素并不是某个牛掰的算法。书中的隐喻，我自己的理解是在构建软件过程中对软件的一种需求上的感悟，是非理性的，恰好和算法这种理性思维形成互补，就像阴阳八卦图中的黑白两部分共同构成一个圆一样。不过，我隐约觉得，构建软件过程中隐喻的重要性要高于个别具体算法。&lt;/p>
&lt;p>之后作者针对于软件过程中的隐喻给出了几种不同类型的软件隐喻。我觉得软件的隐喻很耐人寻味，因为它同样突破了固有的计算机领域，同样可以扩展到世间万物，上升到方法论的高度。&lt;/p>
&lt;h2 id="第三章三思而后行前期准备">第三章－三思而后行：前期准备&lt;/h2>
&lt;p>本章主要讲述了构建软件的前期准备工作。针对不同的软件类型，采取不同的准备策略，例如遇到什么样的客户需要制定哪些策略。并用实际的科学数据表明如果前期准备不够充分会由于软件的进度的不同所遭受的损失比例。总之一句话，前期准备是重中之重，并举例说明了软件开发的不同阶段对前期准备会产生哪些影响。我觉得，这些可以起到指导作用，需要很强的实际操作经验才能驾驭或者说熟练的运用，并不是另一个红头文件。之后描述了架构包括哪些具体的内容，需要考虑哪些方面。觉得很多还是需要不断的实践才能深刻的理解其中的意味，单看这些罗列的文字没什么太大的意义。&lt;/p>
&lt;h2 id="第四章关键的构建决策">第四章－关键的“构建”决策&lt;/h2>
&lt;p>这一章主要是构建过程中，编程语言的选择问题。并介绍了几种常见的语言都有哪些特点。书中有一句话让我不太认同&lt;/p>
&lt;blockquote>
&lt;p>(page.66~page.67) &amp;hellip;，我还看到了 Web 的崛起和 Windows 的衰落。我只能假设当你读到这本书的时候，又会有某些新的技术蒸蒸日上，而我今天(2004年)所知道的 Web 编程将会慢慢消失。这些技术周期(或者说是技术浪潮)意味着不同的编程实践，编程实践取决于你在技术浪潮所处的位置。&lt;/p>
&lt;/blockquote>
&lt;p>很显然，目前来看(2013年) Web 编程不会消失，而且还会有成为主流的可能。说说我的想法，对于未来移动端会被 Web 取代的这种说法我也不敢完全认同。我认为未来会是移动终端的 UI 加上 Web 的后端会成为主流(或者说是云端？)，因为我认为 Web 的 &lt;!-- raw HTML omitted -->URL&lt;!-- raw HTML omitted --> 对于普通大众来说是使用 Web 的一个门槛，远远没有移动端的 UI 更友好。当然了，我也像作者一样给自己留条后路，我只能假设当你读到此篇博客的时候，又会有某些新的技术蒸蒸日上，而我今天(2013年)所知道的 Web 的 &lt;!-- raw HTML omitted -->URL&lt;!-- raw HTML omitted --> 会慢慢退化。&lt;/p>
&lt;p>至于书中的语言介绍，我就不总结了，以免招致“杀身之祸”。但作者的一个观点，我觉得非常有启发。引用书中的解释&lt;/p>
&lt;blockquote>
&lt;p>(page.68) gries对“在一种语言上编程(programming in a language)”和“深入一种语言去编程(programming into a language)”做了区分。“在一种语言上编程”的程序员将他们的思想限制于“语言直接支持的那些构件”。如果语言工具是初级的，那么程序员的思想也是初级的。“深入一种语言去编程”的程序员首先决定他要表达的思想是什么，然后决定如何使用特定语言提供的工具来表达这些思想&lt;/p>
&lt;/blockquote>
&lt;p>其实，我的理解是，要让语言为你的思想服务，而不要让你的思想服务于语言。&lt;/p></description></item><item><title>打造 Facebook</title><link>https://ohcoder.com/post/2013/01/20/building-facebook/</link><pubDate>Sun, 20 Jan 2013 00:00:00 +0000</pubDate><guid>https://ohcoder.com/post/2013/01/20/building-facebook/</guid><description>&lt;img src="https://ohcoder.com/post/2013/01/20/building-facebook/title.jpg" alt="Featured image of post 打造 Facebook" />&lt;p>本来没打算读这本书，碰巧今天上午在&lt;!-- raw HTML omitted -->多看阅读&lt;!-- raw HTML omitted -->上看到有卖电子版，而且比纸质书便宜一半多(12元，纸质书网购要27.5元)，所以就买了下来，然后花了多半天的时间读完了。&lt;/p>
&lt;p>不能免俗，跟看其他牛b公司的传奇故事类似，从老扎的聪明才智说起。&lt;/p>
&lt;p>紧接着作者就不小心闯入facebook，开始了近5年的工作经历。从facebook的“新兵训练营”到黑客文化，此期间无不透露着facebook的工程师文化，给我这个土鳖冲击比较大的几点是：&lt;/p>
&lt;ol>
&lt;li>工程师在facebook非常受尊重。&lt;/li>
&lt;li>管理和技术没有严格的上下级等级观念，只是分工不同，职能不同。&lt;/li>
&lt;li>用生动例子描述了facebook紧张刺激但又很真实的工作生活。&lt;/li>
&lt;li>小团队作战。&lt;/li>
&lt;li>管理方面扁平化，把沟通成本降到最低。&lt;/li>
&lt;li>工程师一般都是超级码农。&lt;/li>
&lt;li>facebook的工作是高度紧张，工作密度很大，当然这也就意味着工程师要有非常强的能力，其中除了技术以外，还要有很好的自我时间管理的能力。&lt;/li>
&lt;li>任何人都可以修改facebook网站，作者还把facebook的网站弄挂了长达半个小时，竟然没有遭受处罚，可见facebook除了内部竞争激烈以外还有包容的一面。&lt;/li>
&lt;li>大团队文化。各个项目组之间不是竞争关系，而是合作关系，此文化避免了很多各个小团队各自为战的心态。&lt;/li>
&lt;/ol>
&lt;p>就列这些吧，列多了就无味了。其实还有很多细节，思想上整体还是蛮受冲击的。&lt;/p>
&lt;p>书的后面主要是作者自己经历的一些事情，包括自己的成长经历，facebook 的招聘流程，产品的发布。关于内部工具这块，facebook非常注重工具的使用，不管是自己开发还是使用开源，亦或是购买第三方，以此来提高工作效率，避免不必要的重复劳动。另外，facebook在产品开始阶段，一般只有几个人，小团队。我比较喜欢这种方式，一来可以降低沟通成本，避免不必要的沟通上产生的误会，二来更加灵活多变。&lt;/p>
&lt;p>另外，纠正一个认识上的误区，现在网上经常有人说“代码胜于雄辩”，给人的感觉好像在说，“别废话，写个代码看看。”其实，在facebook，这句话的意思是相对产品来说的，比如你有一个想法总觉得多么的靠谱，不要讲很多漂亮话，上线看看用户反应再说。所以抛开产品这个前提，“代码胜于雄辩”就有让人误解为“只要实现不求质量”的理解偏差。&lt;/p>
&lt;p>另外一点就是facebook的产品发布一套自有方法，叫做灰度发布(Gated Launch)。基本逻辑就是先让小部分用户使用刚上线的功能作为试水，如果符合预期，然后再逐步放开。&lt;/p>
&lt;p>关于facebook的小团队，我觉得还是蛮牛b的。7、8个人的团队就可以完成非常大的产品。作者说facebook每个工程师都可以抗几百万的用户，太牛b了。&lt;/p>
&lt;p>书的最后部分作者借助此书也谈论了一下自己在国内开始做天使投资的看法和投资方向。其中包括了对中国国内创业公司氛围面临的问题做了概括。&lt;/p>
&lt;p>书的最后，我很佩服作者关于破坏性创新在中国推行的勇气。比如他谈到自己投资的“宝宝拍拍”这样一个产品，他说如果做成了这个也是比较小的公司，但是却会改变很多年轻父母与孩子的成长方式。这种所谓的破坏性创新，不用改变每个人的生活，只让某一类人的生活变得更加顺畅，能做成这样的事情不就非常开心吗？&lt;/p>
&lt;p>这让我明白一个道理，一个事物的存在价值不在于他的受众有多少，而在于其的独特性，你认为呢？&lt;/p>
&lt;p>最后我也不能免俗，称赞一句，在facebook有一群牛b的人，做了一件牛b的事情，过程还是蛮刺激的。&lt;/p></description></item></channel></rss>